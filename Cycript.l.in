/* Cycript - Optimizing JavaScript Compiler/Runtime
 * Copyright (C) 2009-2010  Jay Freeman (saurik)
*/

/* GNU Lesser General Public License, Version 3 {{{ */
/*
 * Cycript is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Cycript is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Cycript.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

/* XXX: supposedly I will be screwed on very very long multi-line comments and need to replace these with a manual lexer. http://websrv.cs.fsu.edu/~engelen/courses/COP5621/Pr2.pdf */

%{
#define YYLTYPE cy::location
#include "Cycript.tab.hh"
typedef cy::parser::token tk;

#define YY_EXTRA_TYPE CYDriver *

#define F(value) do { \
    int token(value); \
    return token; \
} while (false)

#define A new($pool)
#define Y apr_pstrmemdup($pool, yytext, yyleng)

#define I(type, Type, value) do { \
    yylval->type ## _ = A CY ## Type; \
    F(value); \
} while (false)

#define T yylval->newline_ = yyextra->state_ == CYNewLine; BEGIN(Div);
#define C T yyextra->state_ = CYClear;
#define R T yyextra->state_ = CYRestricted;

#define E L C I(literal, RegEx(Y), tk::RegularExpressionLiteral);

#define N \
    if (yyextra->state_ != CYNewLine) { \
        if (yyextra->state_ != CYRestricted) \
            yyextra->state_ = CYNewLine; \
        else { \
            yyextra->state_ = CYClear; \
            F(tk::NewLine); \
        } \
    }

#define V(more) { \
    if (const char *nl = reinterpret_cast<const char *>(memchr(yytext, '\n', yyleng))) { \
        unsigned lines(0); \
        size_t left; \
        do { \
            ++lines; \
            left = yyleng - (nl - yytext) - 1; \
            nl = reinterpret_cast<const char *>(memchr(nl + 1, '\n', left)); \
        } while (nl != NULL); \
        yylloc->end.lines(lines); \
        yylloc->end.columns(left); \
        yylloc->step(); \
        more \
    } else L \
}

#define L { \
    yylloc->step(); \
    yylloc->columns(yyleng); \
}

int H(char c) {
    if (c >= '0' && c <= '9')
        return c - '0';
    if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
    return -1;
}

#define YY_INPUT(data, value, size) { \
    if (yyextra->file_ != NULL) { \
        size_t copy(fread(data, 1, size, yyextra->file_)); \
        value = copy == 0 ? YY_NULL : copy; \
    } else if (yyextra->size_ == 0) \
        value = YY_NULL; \
    else { \
        size_t copy(size); \
        copy = (std::min(copy, yyextra->size_)); \
        memcpy(data, yyextra->data_, copy); \
        yyextra->data_ += copy; \
        yyextra->size_ -= copy; \
        value = copy; \
    } \
}

%}

%option prefix="cy"
%option bison-bridge
%option bison-locations
%option noyywrap
%option yylineno
%option nounput
%option interactive
%option reentrant
%option stack

Exponent [eE][+-]?[0-9]+
Escape   \\[\\'"bfnrtv]|\\0|\\x[0-9a-fA-F]{2}|\\u[0-9a-fA-F]{4}|\\\n

IdentifierStart [a-zA-Z$_]
IdentifierPart  [a-zA-Z$_0-9]

NonTerminator [^\n]
BackslashSequence \\{NonTerminator}
RegularExpressionFirstChar [^\n*\\/]|{BackslashSequence}
RegularExpressionChar [^\n\\/]|{BackslashSequence}
RegularExpressionFlags {IdentifierPart}*
RegularExpressionChars {RegularExpressionChar}*
RegularExpressionBody {RegularExpressionFirstChar}{RegularExpressionChars}

@begin E4X
XMLNameStart [a-zA-Z_:]
XMLNamePart [a-zA-Z0-9.-_:]
XMLName {XMLNameStart}{XMLNamePart}*
@end

%s Div
%s RegExp

@begin E4X
%x XMLContent
%x XMLTag
@end

%%

<RegExp>\/{RegularExpressionBody}\/{RegularExpressionFlags} E

\/\/[^\n]* L

	/* http://ostermiller.org/findcomment.html */
	/* XXX: unify these two rules using !? */
\/\*!([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/ V() C I(comment, Comment(Y), tk::Comment);
\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/ V(N)

@begin E4X
<RegExp>"<>"      L F(tk::LeftRight);
<XMLContent>"</>" L F(tk::LeftSlashRight);

<RegExp,XMLContent>\<!\[CDATA\[(\n|[^[]|\[[^[]|\[\[[^>])*]]> V() F(tk::XMLCDATA);
<RegExp,XMLContent>\<!--(\n|[^-]|-[^-])*--> V() F(tk::XMLComment);
<RegExp,XMLContent>\<?(\n|[^?]|\?[^>])*?> V() F(tk::XMLPI);

<XMLTag>"="  L F(tk::Equal);
<XMLTag>">"  L F(tk::Right);
<XMLTag>"/>" L F(tk::SlashRight);
<XMLTag>"{"  L F(tk::OpenBrace);

<XMLTag>\"(\n|[^"])*\"|'(\n|[^'])*' V() F(tk::XMLAttributeValue);
<XMLTag>{XMLName} L F(tk::XMLName);
<XMLTag>[ \t\r\n] V() F(tk::XMLWhitespace);

<XMLContent>"{"  L F(tk::OpenBrace);
<XMLContent>"<"  L F(tk::Left);
<XMLContent>"</" L F(tk::LeftSlash);
@end

"..."  L C F(tk::PeriodPeriodPeriod);

@begin E4X
"::"   L C F(tk::ColonColon);
".."   L C F(tk::PeriodPeriod);
@end

@begin E4X ObjectiveC
"@"    L C F(tk::At);
@end

"&"    L C F(tk::Ampersand);
"&&"   L C F(tk::AmpersandAmpersand);
"&="   L C F(tk::AmpersandEqual);
"^"    L C F(tk::Carrot);
"^="   L C F(tk::CarrotEqual);
"="    L C F(tk::Equal);
"=="   L C F(tk::EqualEqual);
"==="  L C F(tk::EqualEqualEqual);
"!"    L C F(tk::Exclamation);
"!="   L C F(tk::ExclamationEqual);
"!=="  L C F(tk::ExclamationEqualEqual);
"-"    L C F(tk::Hyphen);
"-="   L C F(tk::HyphenEqual);
"--"   L C F(yylval->newline_ ? tk::HyphenHyphen_ : tk::HyphenHyphen);
"->"   L C F(tk::HyphenRight);
"<"    L C F(tk::Left);
"<="   L C F(tk::LeftEqual);
"<<"   L C F(tk::LeftLeft);
"<<="  L C F(tk::LeftLeftEqual);
"%"    L C F(tk::Percent);
"%="   L C F(tk::PercentEqual);
"."    L C F(tk::Period);
"|"    L C F(tk::Pipe);
"|="   L C F(tk::PipeEqual);
"||"   L C F(tk::PipePipe);
"+"    L C F(tk::Plus);
"+="   L C F(tk::PlusEqual);
"++"   L C F(yylval->newline_ ? tk::PlusPlus_ : tk::PlusPlus);
">"    L C F(tk::Right);
">="   L C F(tk::RightEqual);
">>"   L C F(tk::RightRight);
">>="  L C F(tk::RightRightEqual);
">>>"  L C F(tk::RightRightRight);
">>>=" L C F(tk::RightRightRightEqual);
"*"    L C F(tk::Star);
"*="   L C F(tk::StarEqual);
"~"    L C F(tk::Tilde);

<Div>"/"  L C F(tk::Slash);
<Div>"/=" L C F(tk::SlashEqual);

":"    L C F(tk::Colon);
","    L C F(tk::Comma);
"?"    L C F(tk::Question);
";"    L C F(tk::SemiColon);

"("    L C F(tk::OpenParen);
")"    L C F(tk::CloseParen);

"{"    L C F(yylval->newline_ ? tk::OpenBrace_ : tk::OpenBrace);
"}"    L C F(tk::CloseBrace);

"["    L C F(tk::OpenBracket);
"]"    L C F(tk::CloseBracket);

@begin Java
"@class"          L C F(tk::AtClass);
@end

@begin ObjectiveC
"@end"            L C F(tk::AtEnd);
"@implementation" L C F(tk::AtImplementation);
"@import"         L C F(tk::AtImport);
"@selector"       L C F(tk::AtSelector);
@end

"false"        L C I(false, False(), tk::False);
"null"         L C I(null, Null(), tk::Null);
"true"         L C I(true, True(), tk::True);

"break"        L R I(word, Word("break"), tk::Break);
"case"         L C I(word, Word("case"), tk::Case);
"catch"        L C I(word, Word("catch"), tk::Catch);
"continue"     L R I(word, Word("continue"), tk::Continue);
"default"      L C I(word, Word("default"), tk::Default);
"delete"       L C I(word, Word("delete"), tk::Delete);
"do"           L C I(word, Word("do"), tk::Do);
"else"         L C I(word, Word("else"), tk::Else);
"finally"      L C I(word, Word("finally"), tk::Finally);
"for"          L C I(word, Word("for"), tk::For);
"function"     L C I(word, Word("function"), tk::Function);
"if"           L C I(word, Word("if"), tk::If);
"in"           L C I(word, Word("in"), yyextra->in_.top() ? tk::In_ : tk::In);
"instanceof"   L C I(word, Word("instanceof"), tk::InstanceOf);
"new"          L C I(word, Word("new"), tk::New);
"return"       L R I(word, Word("return"), tk::Return);
"switch"       L C I(word, Word("switch"), tk::Switch);
"this"         L C I(this, This(), tk::This);
"throw"        L R I(word, Word("throw"), tk::Throw);
"try"          L C I(word, Word("try"), tk::Try);
"typeof"       L C I(word, Word("typeof"), tk::TypeOf);
"var"          L C I(word, Word("var"), tk::Var);
"void"         L C I(word, Word("void"), tk::Void);
"while"        L C I(word, Word("while"), tk::While);
"with"         L C I(word, Word("with"), tk::With);

"debugger"     L C I(word, Word("debugger"), tk::Debugger);

"const"        L C I(word, Word("const"), tk::Const);

"class"        L C I(word, Word("class"), tk::Class);
"enum"         L C I(word, Word("enum"), tk::Enum);
"export"       L C I(word, Word("export"), tk::Export);
"extends"      L C I(word, Word("extends"), tk::Extends);
"import"       L C I(word, Word("import"), tk::Import);
"super"        L C I(word, Word("super"), tk::Super);

"implements"   L C I(identifier, Identifier("implements"), tk::Implements);
"interface"    L C I(identifier, Identifier("interface"), tk::Interface);
"package"      L C I(identifier, Identifier("package"), tk::Package);
"private"      L C I(identifier, Identifier("private"), tk::Private);
"protected"    L C I(identifier, Identifier("protected"), tk::Protected);
"public"       L C I(identifier, Identifier("public"), tk::Public);
"static"       L C I(identifier, Identifier("static"), tk::Static);

"abstract"     L C I(identifier, Identifier("abstract"), tk::Abstract);
"boolean"      L C I(identifier, Identifier("boolean"), tk::Boolean);
"byte"         L C I(identifier, Identifier("byte"), tk::Byte);
"char"         L C I(identifier, Identifier("char"), tk::Char);
"double"       L C I(identifier, Identifier("double"), tk::Double);
"final"        L C I(identifier, Identifier("final"), tk::Final);
"float"        L C I(identifier, Identifier("float"), tk::Float);
"goto"         L C I(identifier, Identifier("goto"), tk::Goto);
"int"          L C I(identifier, Identifier("int"), tk::Int);
"long"         L C I(identifier, Identifier("long"), tk::Long);
"native"       L C I(identifier, Identifier("native"), tk::Native);
"short"        L C I(identifier, Identifier("short"), tk::Short);
"synchronized" L C I(identifier, Identifier("synchronized"), tk::Synchronized);
"throws"       L C I(identifier, Identifier("throws"), tk::Throws);
"transient"    L C I(identifier, Identifier("transient"), tk::Transient);
"volatile"     L C I(identifier, Identifier("volatile"), tk::Volatile);

"let"          L C I(identifier, Identifier("let"), tk::Let);
"yield"        L C I(identifier, Identifier("yield"), tk::Yield);

"each"         L C I(identifier, Identifier("each"), tk::Each);

@begin E4X
"namespace"    L C I(identifier, Identifier("namespace"), tk::Namespace);
"xml"          L C I(identifier, Identifier("xml"), tk::XML);
@end

{IdentifierStart}{IdentifierPart}* L C I(identifier, Identifier(Y), tk::Identifier_);

(\.[0-9]+|(0|[1-9][0-9]*)(\.[0-9]*)?){Exponent}? L C I(number, Number(strtod(yytext, NULL)), tk::NumericLiteral);

0[xX][0-9a-fA-F]+ L C I(number, Number(strtoull(yytext + 2, NULL, 16)), tk::NumericLiteral);
0[0-7]+ L C I(number, Number(strtoull(yytext + 1, NULL, 8)), tk::NumericLiteral);
0[bB][0-1]+ L C I(number, Number(strtoull(yytext + 2, NULL, 2)), tk::NumericLiteral);

\"([^"\\\n]|{Escape})*\"|'([^'\\\n]|{Escape})*' L C {
    char *value(A char[yyleng]);
    char *local(value);

    for (yy_size_t i(1), e(yyleng - 1); i != e; ++i) {
        char next(yytext[i]);

        if (yytext[i] == '\\')
            switch (next = yytext[++i]) {
                case '\n': continue;
                case '\\': next = '\\'; break;
                case '\'': next = '\''; break;
                case '"': next = '"'; break;
                case 'b': next = '\b'; break;
                case 'f': next = '\f'; break;
                case 'n': next = '\n'; break;
                case 'r': next = '\r'; break;
                case 't': next = '\t'; break;
                case 'v': next = '\v'; break;
                case '0': next = '\0'; break;

                case 'x':
                    next = H(yytext[i + 1]) << 4 | H(yytext[i + 2]);
                    i += 2;
                break;
            }

        *local++ = next;
    }

    *local = '\0';
    I(string, String(value, local - value), tk::StringLiteral);
}

\r?\n|\r|\xe2\x80[\xa8\xa9] yylloc->end.lines(); yylloc->step(); N

[ \t] L

<<EOF>> if (yyextra->auto_) { yyextra->auto_ = false; F(tk::AutoComplete); } L yyterminate();

. L {
    CYDriver::Error error;
    error.location_ = *yylloc;
    error.message_ = "syntax error, unknown token";
    yyextra->errors_.push_back(error);
    yyterminate();
}

%%

void CYDriver::ScannerInit() {
    cylex_init(&scanner_);
    cyset_extra(this, scanner_);
}

void CYDriver::ScannerDestroy() {
    cylex_destroy(scanner_);
}

CYDriver::Condition CYDriver::GetCondition() {
    switch (yy_top_state(scanner_)) {
        case RegExp:
            return RegExpCondition;
@begin E4X
        case XMLContent:
            return XMLContentCondition;
        case XMLTag:
            return XMLTagCondition;
@end
        default:
            _assert(false);
    }
}

void CYDriver::SetCondition(Condition condition) {
    struct yyguts_t *yyg(reinterpret_cast<struct yyguts_t *>(scanner_));

    switch (condition) {
        case RegExpCondition:
            BEGIN(RegExp);
            break;
@begin E4X
        case XMLContentCondition:
            BEGIN(XMLContent);
            break;
        case XMLTagCondition:
            BEGIN(XMLTag);
            break;
@end
        default:
            _assert(false);
    }
}

void CYDriver::PushCondition(Condition condition) {
    switch (condition) {
        case RegExpCondition:
            yy_push_state(RegExp, scanner_);
            break;
@begin E4X
        case XMLContentCondition:
            yy_push_state(XMLContent, scanner_);
            break;
        case XMLTagCondition:
            yy_push_state(XMLTag, scanner_);
            break;
@end
        default:
            _assert(false);
    }
}

void CYDriver::PopCondition() {
    yy_pop_state(scanner_);
}

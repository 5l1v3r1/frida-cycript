/* Cycript - Optimizing JavaScript Compiler/Runtime
 * Copyright (C) 2009-2015  Jay Freeman (saurik)
*/

/* GNU Affero General Public License, Version 3 {{{ */
/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.

 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

%top{
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-register"
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wunused-variable"
#else
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-compare"
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-variable"
#endif
}

%{

#define YYLTYPE CYLocation
#include "Cycript.tab.hh"
typedef cy::parser::token tk;

#include "Highlight.hpp"

#define YY_EXTRA_TYPE CYDriver *

// do /not/ fold token to the return: this is a macro and the ordering is dependent
#define F(value, highlight) do { \
    int token(value); \
@begin ObjectiveC
    yyextra->no_.AtImplementation = false; \
@end
    yyextra->no_.Class = false; \
    yyextra->no_.Function = false; \
    yyextra->no_.NewLine = false; \
    yyextra->no_.OpenBrace = false; \
    yylval->highlight_ = highlight; \
    return token; \
} while (false)

#define P yyextra->pool_
#define A new(P)
#define Y P.strmemdup(yytext, yyleng)

#define I(type, Type, value, highlight) do { \
    yylval->semantic_.type ## _ = A CY ## Type; \
    F(value, highlight); \
} while (false)

#define C \
    yyextra->newline_ = yyextra->last_; \
    yyextra->last_ = false; \
    BEGIN(yyextra->template_.top() ? DivOrTemplateTail : Div);

#define N \
    if (yyextra->last_ && yyextra->no_.NewLine) { \
        yyextra->last_ = false; \
        F(tk::NewLine, hi::Nothing); \
    }

#define V(more) { \
    if (const char *nl = reinterpret_cast<const char *>(memchr(yytext, '\n', yyleng))) { \
        unsigned lines(0); \
        size_t left; \
        do { \
            ++lines; \
            left = yyleng - (nl - yytext) - 1; \
            nl = reinterpret_cast<const char *>(memchr(nl + 1, '\n', left)); \
        } while (nl != NULL); \
        yylloc->step(); \
        yylloc->end.lines(lines); \
        yylloc->end.columns(left); \
        more \
    } else L \
}

#define R yylloc->end.columns(yyleng);
#define L yylloc->step(); R

#define H(value, highlight) do { \
    if (yyextra->highlight_) \
        F(value, highlight); \
} while (false)

#define M \
    H(tk::Comment, hi::Comment);

#define E(message) { \
    CYDriver::Error error; \
    error.location_ = *yylloc; \
    error.message_ = "syntax error, " message; \
    yyextra->errors_.push_back(error); \
    yyterminate(); \
}

int X(char c) {
    if (c >= '0' && c <= '9')
        return c - '0';
    if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
    return -1;
}

template <typename Type_>
static void U(Type_ &local, unsigned point) {
    if (false) {
    } else if (point < 0x000080) {
        *local++ = point;
    } else if (point < 0x000800) {
        *local++ = 0xc0 | point >> 0x06 & 0x1f;
        goto one;
    } else if (point < 0x010000) {
        *local++ = 0xe0 | point >> 0x0c & 0x0f;
        goto two;
    } else if (point < 0x110000) {
        *local++ = 0xf0 | point >> 0x12 & 0x07;
        *local++ = 0x80 | point >> 0x0c & 0x3f;
      two:
        *local++ = 0x80 | point >> 0x06 & 0x3f;
      one:
        *local++ = 0x80 | point >> 0x00 & 0x3f;
    } else _assert(false);
}

static void U(char *&local, const char *text, yy_size_t &i) {
    unsigned point;

    char next(text[++i]);
    if (next != '{') {
        point = X(text[i + 0]) << 12 | X(text[i + 1]) << 8 | X(text[i + 2]) << 4 | X(text[i + 3]);
        i += 3;
    } else {
        point = 0;
        for (;;) {
            next = text[++i];
            if (next == '}')
                break;
            point = (point << 4) | X(next);
        }
    }

    U(local, point);
}

#define CYLexBufferPoint(point) do { \
    std::back_insert_iterator<std::vector<char> > inserter(yyextra->buffer_); \
    U(inserter, point); \
} while (false)

#define CYLexBufferUnit(value) do { \
    yyextra->buffer_.push_back(value); \
} while (false)

#define CYLexBufferUnits(data, size) do { \
    yyextra->buffer_.insert(yyextra->buffer_.end(), data, data + size); \
} while (false)

#define CYLexBufferStart(condition) do { \
    yyextra->buffer_.clear(); \
    yy_push_state(condition, yyscanner); \
} while (false)

#define CYLexBufferEnd(type, Type, value, highlight) do { \
    yy_pop_state(yyscanner); \
    C I(type, Type(P.strmemdup(yyextra->buffer_.data(), yyextra->buffer_.size()), yyextra->buffer_.size()), value, highlight); \
} while (false)

#define YY_INPUT(data, value, size) { \
    if (yyextra->data_.eof()) \
        value = YY_NULL; \
    else { \
        yyextra->data_.read(data, size); \
        size_t copy(yyextra->data_.gcount()); \
        value = copy == 0 ? YY_NULL : copy; \
    } \
}

%}

%option prefix="cy"
%option bison-bridge
%option bison-locations
%option nodefault
%option noyywrap
%option noyylineno
%option nounput
%option nounistd
%option 8bit
%option backup
%option batch
%option never-interactive
%option pointer
%option reentrant
%option stack

%option full
%option ecs

U1 [\x00-\x7f]
U0 [\x80-\xbf]
U2 [\xc2-\xdf]
U3 [\xe0-\xef]
U4 [\xf0-\xf4]
UN [\xc0-\xc1\xf5-\xff]

HexDigit [0-9a-fA-F]
LineTerminatorSequence \r?\n|\r|\xe2\x80[\xa8\xa9]
WhiteSpace [\x09\x0b\x0c\x20]|\xc2\xa0|\xef\xbb\xbf
UnicodeEscape \\u({HexDigit}{4}|\{{HexDigit}+\})

@include NotLineTerminator.l
CommentCharacter [^*/]{-}[\r\n\x80-\xff]|{NotLineTerminator}
SingleCharacter [^'\\]{-}[\r\n\x80-\xff]|{NotLineTerminator}
DoubleCharacter [^"\\]{-}[\r\n\x80-\xff]|{NotLineTerminator}
PlateCharacter [^$`\\]{-}[\r\n\x80-\xff]|{NotLineTerminator}

@include UnicodeIDStart.l
@include UnicodeIDContinue.l
IdentifierMore [$_]

UnicodeStart {IdentifierMore}|{UnicodeIDStart}
UnicodePart {IdentifierMore}|\xe2\x80[\x8c\x8d]|{UnicodeIDContinue}
UnicodeFail {U2}|{U3}|{U3}{U0}|{U4}|{U4}{U0}|{U4}{U0}{U0}|{UN}|{U0}
UnicodeScrap {UnicodePart}*{UnicodeFail}?

IdentifierStart {UnicodeStart}|{UnicodeEscape}
IdentifierPart {UnicodePart}|{UnicodeEscape}
IdentifierFail {UnicodeFail}|\\(u({HexDigit}{0,3}|\{{HexDigit}*))?
IdentifierScrap {IdentifierPart}*{IdentifierFail}?

NonTerminator [^\n]
BackslashSequence \\{NonTerminator}
RegularExpressionFirstChar [^\n*\\/]|{BackslashSequence}
RegularExpressionChar [^\n\\/]|{BackslashSequence}
RegularExpressionFlags {UnicodePart}*
RegularExpressionChars {RegularExpressionChar}*
RegularExpressionBody {RegularExpressionFirstChar}{RegularExpressionChars}

@begin E4X
XMLNameStart [a-zA-Z_:]
XMLNamePart [a-zA-Z0-9.-_:]
XMLName {XMLNameStart}{XMLNamePart}*
@end

%x MultiLine

%x LegacySingleString
%x LegacyDoubleString

%x StrictSingleString
%x StrictDoubleString
%x StrictAccentString

%s Div
%s DivOrTemplateTail
%s RegExp
%s RegExpOrTemplateTail

@begin E4X
%x XMLContent
%x XMLTag
@end

%%

    /* RegEx {{{ */
<RegExp,RegExpOrTemplateTail>{
    \/{RegularExpressionBody}\/{RegularExpressionFlags} L C I(literal, RegEx(Y), tk::RegularExpressionLiteral, hi::Constant);
    \/{RegularExpressionBody}\/{RegularExpressionFlags}{UnicodeFail} L E("invalid flags")
    \/{RegularExpressionBody}?\\? L E("unterminated regex")
}
    /* }}} */
    /* Comment {{{ */
#![^\n]* L M
\/\/[^\n]* L M

\/\* L yy_push_state(MultiLine, yyscanner);

<MultiLine>{
    \**\*\/ R yy_pop_state(yyscanner); M N
    \**{LineTerminatorSequence} yylloc->end.lines(); yyextra->last_ = true;
    \**{CommentCharacter}|\/ R
    \**({UnicodeFail}|\*) R E("invalid comment");
    <<EOF>> R E("invalid comment")
}
    /* }}} */
    /* Element {{{ */
@begin E4X
<RegExp>"<>"      L F(tk::LeftRight, hi::Structure);
<XMLContent>"</>" L F(tk::LeftSlashRight, hi::Structure);

<RegExp,XMLContent>\<!\[CDATA\[(\n|[^[]|\[[^[]|\[\[[^>])*]]> V() F(tk::XMLCDATA, hi::Constant);
<RegExp,XMLContent>\<!--(\n|[^-]|-[^-])*--> V() F(tk::XMLComment, hi::Comment);
<RegExp,XMLContent>\<?(\n|[^?]|\?[^>])*?> V() F(tk::XMLPI, hi::Meta);

<XMLTag>"="  L F(tk::Equal, hi::Structure);
<XMLTag>">"  L F(tk::Right, hi::Structure);
<XMLTag>"/>" L F(tk::SlashRight, hi::Structure);
<XMLTag>"{"  L F(tk::OpenBrace, hi::Structure);

<XMLTag>\"(\n|[^"])*\"|'(\n|[^'])*' V() F(tk::XMLAttributeValue, hi::Constant);
<XMLTag>{XMLName} L F(tk::XMLName, hi::Identifier);
<XMLTag>[ \t\r\n] V() F(tk::XMLWhitespace, hi::Nothing);

<XMLContent>"{"  L F(tk::OpenBrace, hi::Structure);
<XMLContent>"<"  L F(tk::Left, hi::Structure);
<XMLContent>"</" L F(tk::LeftSlash, hi::Structure);
@end
    /* }}} */
    /* Operator {{{ */
"..."  L C F(tk::PeriodPeriodPeriod, hi::Meta);
".."   L E("invalid operator")

@begin E4X
"::"   L C F(tk::ColonColon, hi::Operator);
".."   L C F(tk::PeriodPeriod, hi::Operator);
@end

@begin E4X ObjectiveC
"@"    L C F(tk::At, hi::Operator);
"#"    L C F(tk::Pound, hi::Operator);
@end

"&"    L C F(tk::Ampersand, hi::Operator);
"&&"   L C F(tk::AmpersandAmpersand, hi::Operator);
"&="   L C F(tk::AmpersandEqual, hi::Operator);
"^"    L C F(tk::Carrot, hi::Operator);
"^="   L C F(tk::CarrotEqual, hi::Operator);
"="    L C F(tk::Equal, hi::Operator);
"=="   L C F(tk::EqualEqual, hi::Operator);
"==="  L C F(tk::EqualEqualEqual, hi::Operator);
"=>"   L C F(yyextra->newline_ ? tk::EqualRight_ : tk::EqualRight, hi::Operator);
"!"    L C F(tk::Exclamation, hi::Operator);
"!="   L C F(tk::ExclamationEqual, hi::Operator);
"!=="  L C F(tk::ExclamationEqualEqual, hi::Operator);
"-"    L C F(tk::Hyphen, hi::Operator);
"-="   L C F(tk::HyphenEqual, hi::Operator);
"--"   L C F(yyextra->newline_ ? tk::HyphenHyphen_ : tk::HyphenHyphen, hi::Operator);
"->"   L C F(tk::HyphenRight, hi::Operator);
"<"    L C F(tk::Left, hi::Operator);
"<="   L C F(tk::LeftEqual, hi::Operator);
"<<"   L C F(tk::LeftLeft, hi::Operator);
"<<="  L C F(tk::LeftLeftEqual, hi::Operator);
"%"    L C F(tk::Percent, hi::Operator);
"%="   L C F(tk::PercentEqual, hi::Operator);
"."    L C F(tk::Period, hi::Operator);
"|"    L C F(tk::Pipe, hi::Operator);
"|="   L C F(tk::PipeEqual, hi::Operator);
"||"   L C F(tk::PipePipe, hi::Operator);
"+"    L C F(tk::Plus, hi::Operator);
"+="   L C F(tk::PlusEqual, hi::Operator);
"++"   L C F(yyextra->newline_ ? tk::PlusPlus_ : tk::PlusPlus, hi::Operator);
">"    L C F(tk::Right, hi::Operator);
">="   L C F(tk::RightEqual, hi::Operator);
">>"   L C F(tk::RightRight, hi::Operator);
">>="  L C F(tk::RightRightEqual, hi::Operator);
">>>"  L C F(tk::RightRightRight, hi::Operator);
">>>=" L C F(tk::RightRightRightEqual, hi::Operator);
"*"    L C F(tk::Star, hi::Operator);
"*="   L C F(tk::StarEqual, hi::Operator);
"~"    L C F(tk::Tilde, hi::Operator);

<Div,DivOrTemplateTail>"/"  L C F(tk::Slash, hi::Operator);
<Div,DivOrTemplateTail>"/=" L C F(tk::SlashEqual, hi::Operator);

":"    L C F(tk::Colon, hi::Structure);
","    L C F(tk::Comma, hi::Structure);
"?"    L C F(tk::Question, hi::Structure);
";"    L C F(tk::SemiColon, hi::Structure);

"("    L C F(tk::OpenParen, hi::Structure);
")"    L C F(tk::CloseParen, hi::Structure);

"{"    L yyextra->template_.push(false); C F(yyextra->no_.OpenBrace ? tk::OpenBrace__ : yyextra->newline_ ? tk::OpenBrace_ : tk::OpenBrace, hi::Structure);
<Div,RegExp>"}" L yyextra->template_.pop(); C F(tk::CloseBrace, hi::Structure);

"["    L C F(tk::OpenBracket, hi::Structure);
"]"    L C F(tk::CloseBracket, hi::Structure);
    /* }}} */
    /* Keyword {{{ */
"@error"          L C F(tk::At_error_, hi::Error);

@begin Java
"@class"          L C F(tk::At_class_, hi::Meta);
@end

@begin C
"@encode"         L C F(tk::At_encode_, hi::Meta);
@end

@begin ObjectiveC
"@end"            L C F(tk::At_end_, hi::Meta);
"@false"          L C F(tk::At_false_, hi::Constant);
"@implementation" L C F(yyextra->no_.AtImplementation ? tk::At_implementation__ : tk::At_implementation_, hi::Meta);
"@import"         L C F(tk::At_import_, hi::Special);
"@NO"             L C F(tk::At_NO_, hi::Constant);
"@null"           L C F(tk::At_null_, hi::Constant);
"@selector"       L C F(tk::At_selector_, hi::Meta);
"@true"           L C F(tk::At_true_, hi::Constant);
"@YES"            L C F(tk::At_YES_, hi::Constant);
@end

@({UnicodeStart}{UnicodeScrap}|{UnicodeFail}) L E("invalid keyword")
    /* }}} */
    /* Highlight {{{ */
"undefined"       L C F(tk::_undefined_, hi::Operator);

@begin ObjectiveC
"bool"            L C F(tk::_bool_, hi::Type);
"BOOL"            L C F(tk::_BOOL_, hi::Type);
"id"              L C F(tk::_id_, hi::Type);
"nil"             L C F(tk::_nil_, hi::Constant);
"NULL"            L C F(tk::_NULL_, hi::Constant);
"SEL"             L C F(tk::_SEL_, hi::Type);
@end
    /* }}} */
    /* Reserved {{{ */
"abstract"        L C /*FII*/ F(tk::_abstract_, hi::Meta);
"await"           L C /*II?*/ F(tk::_await_, hi::Meta);
"boolean"         L C /*FII*/ F(tk::_boolean_, hi::Type);
"break"           L C /*KKK*/ F(tk::_break_, hi::Control);
"byte"            L C /*FII*/ F(tk::_byte_, hi::Type);
"case"            L C /*KKK*/ F(tk::_case_, hi::Control);
"catch"           L C /*KKK*/ F(tk::_catch_, hi::Control);
"char"            L C /*FII*/ F(tk::_char_, hi::Type);
"class"           L C /*FFK*/ F(yyextra->no_.Class ? tk::_class__ : tk::_class_, hi::Meta);
"const"           L C /*FFK*/ F(tk::_const_, hi::Meta);
"continue"        L C /*KKK*/ F(tk::_continue_, hi::Control);
"debugger"        L C /*FKK*/ F(tk::_debugger_, hi::Meta);
"default"         L C /*KKK*/ F(tk::_default_, hi::Control);
"delete"          L C /*KKK*/ F(tk::_delete_, hi::Operator);
"do"              L C /*KKK*/ F(tk::_do_, hi::Control);
"double"          L C /*FII*/ F(tk::_double_, hi::Type);
"else"            L C /*KKK*/ F(tk::_else_, hi::Control);
"enum"            L C /*FFF*/ F(tk::_enum_, hi::Meta);
"export"          L C /*FFK*/ F(tk::_export_, hi::Meta);
"extends"         L C /*FFK*/ F(tk::_extends_, hi::Meta);
"false"           L C /*LLL*/ F(tk::_false_, hi::Constant);
"final"           L C /*FII*/ F(tk::_final_, hi::Meta);
"finally"         L C /*KKK*/ F(tk::_finally_, hi::Control);
"float"           L C /*FII*/ F(tk::_float_, hi::Type);
"for"             L C /*KKK*/ F(tk::_for_, hi::Control);
"function"        L C /*KKK*/ F(yyextra->no_.Function ? tk::_function__ : tk::_function_, hi::Meta);
"goto"            L C /*FII*/ F(tk::_goto_, hi::Control);
"if"              L C /*KKK*/ F(tk::_if_, hi::Control);
"implements"      L C /*FSS*/ F(tk::_implements_, hi::Meta);
"import"          L C /*FFK*/ F(tk::_import_, hi::Meta);
"in"              L C /*KKK*/ F(yyextra->in_.top() ? tk::_in__ : tk::_in_, hi::Operator);
"instanceof"      L C /*KKK*/ F(tk::_instanceof_, hi::Operator);
"int"             L C /*FII*/ F(tk::_int_, hi::Type);
"interface"       L C /*FSS*/ F(tk::_interface_, hi::Meta);
"let"             L C /*IS?*/ F(tk::_let_, hi::Meta);
"long"            L C /*FII*/ F(tk::_long_, hi::Type);
"native"          L C /*FII*/ F(tk::_native_, hi::Meta);
"new"             L C /*KKK*/ F(tk::_new_, hi::Operator);
"null"            L C /*LLL*/ F(tk::_null_, hi::Constant);
"package"         L C /*FSS*/ F(tk::_package_, hi::Meta);
"private"         L C /*FSS*/ F(tk::_private_, hi::Meta);
"protected"       L C /*FSS*/ F(tk::_protected_, hi::Meta);
"public"          L C /*FSS*/ F(tk::_public_, hi::Meta);
"return"          L C /*KKK*/ F(tk::_return_, hi::Control);
"short"           L C /*FII*/ F(tk::_short_, hi::Type);
"static"          L C /*FS?*/ F(tk::_static_, hi::Meta);
"super"           L C /*FFK*/ F(tk::_super_, hi::Constant);
"switch"          L C /*KKK*/ F(tk::_switch_, hi::Control);
"synchronized"    L C /*FII*/ F(tk::_synchronized_, hi::Meta);
"this"            L C /*KKK*/ F(tk::_this_, hi::Constant);
"throw"           L C /*KKK*/ F(tk::_throw_, hi::Control);
"throws"          L C /*FII*/ F(tk::_throws_, hi::Meta);
"transient"       L C /*FII*/ F(tk::_transient_, hi::Meta);
"true"            L C /*LLL*/ F(tk::_true_, hi::Constant);
"try"             L C /*KKK*/ F(tk::_try_, hi::Control);
"typeof"          L C /*KKK*/ F(tk::_typeof_, hi::Operator);
"var"             L C /*KKK*/ F(tk::_var_, hi::Meta);
"void"            L C /*KKK*/ F(tk::_void_, hi::Operator);
"volatile"        L C /*FII*/ F(tk::_volatile_, hi::Meta);
"while"           L C /*KKK*/ F(tk::_while_, hi::Control);
"with"            L C /*KKK*/ F(tk::_with_, hi::Control);
"yield"           L C /*IS?*/ F(tk::_yield_, hi::Control);

"auto"            L C F(tk::_auto_, hi::Meta);
"each"            L C F(tk::_each_, hi::Control);
"of"              L C F(tk::_of_, hi::Operator);

@begin C
"extern"          L C F(tk::_extern_, hi::Type);
"signed"          L C F(tk::_signed_, hi::Type);
"typedef"         L C F(tk::_typedef_, hi::Meta);
"unsigned"        L C F(tk::_unsigned_, hi::Type);
@end

@begin ObjectiveC
"NO"              L C F(tk::_NO_, hi::Constant);
"YES"             L C F(tk::_YES_, hi::Constant);
@end

@begin E4X
"namespace"       L C F(tk::_namespace_, hi::Meta);
"xml"             L C F(tk::_xml_, hi::Meta);
@end
    /* }}} */
    /* Identifier {{{ */
{UnicodeStart}{UnicodePart}* L C I(identifier, Identifier(Y), tk::Identifier_, hi::Identifier);

{IdentifierStart}{IdentifierPart}* L C {
    char *value(A char[yyleng + 1]);
    char *local(value);

    for (yy_size_t i(0), e(yyleng); i != e; ++i) {
        char next(yytext[i]);
        if (next != '\\')
            *local++ = next;
        else
            U(local, yytext, ++i);
    }

    *local = '\0';
    I(identifier, Identifier(value), tk::Identifier_, hi::Identifier);
}

({IdentifierStart}{IdentifierPart}*)?{IdentifierFail} L E("invalid identifier")
    /* }}} */
    /* Number {{{ */
0[0-7]+ L C I(number, Number(strtoull(yytext + 1, NULL, 8)), tk::NumericLiteral, hi::Constant);
0[0-9]+ L C I(number, Number(strtoull(yytext + 1, NULL, 10)), tk::NumericLiteral, hi::Constant);

0[xX][0-9a-fA-F]+ L C I(number, Number(strtoull(yytext + 2, NULL, 16)), tk::NumericLiteral, hi::Constant);
0[oO][0-7]+ L C I(number, Number(strtoull(yytext + 2, NULL, 8)), tk::NumericLiteral, hi::Constant);
0[bB][0-1]+ L C I(number, Number(strtoull(yytext + 2, NULL, 2)), tk::NumericLiteral, hi::Constant);

(\.[0-9]+|(0|[1-9][0-9]*)(\.[0-9]*)?)([eE][+-]?[0-9]+)? L C I(number, Number(strtod(yytext, NULL)), tk::NumericLiteral, hi::Constant);
(\.[0-9]+|(0|[1-9][0-9]*)(\.[0-9]*)?)[eE][+-]?{IdentifierScrap} L E("invalid exponent")
(\.?[0-9]|(0|[1-9][0-9]*)\.){IdentifierScrap} L E("invalid number")
    /* }}} */
    /* String {{{ */
\' L CYLexBufferStart(LegacySingleString);
<LegacySingleString,StrictSingleString>{
    \' R CYLexBufferEnd(string, String, tk::StringLiteral, hi::Constant);
    {SingleCharacter}+ R CYLexBufferUnits(yytext, yyleng);
    {SingleCharacter}*{UnicodeFail} R E("invalid character");
    {LineTerminatorSequence} R E("invalid newline");
}

\" L CYLexBufferStart(LegacyDoubleString);
<LegacyDoubleString,StrictDoubleString>{
    \" R CYLexBufferEnd(string, String, tk::StringLiteral, hi::Constant);
    {DoubleCharacter}+ R CYLexBufferUnits(yytext, yyleng);
    {DoubleCharacter}*{UnicodeFail} R E("invalid character");
    {LineTerminatorSequence} R E("invalid newline");
}
    /* }}} */
    /* Template {{{ */
"`" L yyextra->tail_ = false; CYLexBufferStart(StrictAccentString);
<DivOrTemplateTail,RegExpOrTemplateTail>"}" L yyextra->tail_ = true; yyextra->template_.pop(); CYLexBufferStart(StrictAccentString);

<StrictAccentString>{
    "`" R CYLexBufferEnd(string, String, yyextra->tail_ ? tk::TemplateTail : tk::NoSubstitutionTemplate, hi::Constant);
    "${" R yyextra->template_.push(true); CYLexBufferEnd(string, String, yyextra->tail_ ? tk::TemplateMiddle : tk::TemplateHead, hi::Constant);

    "$" R CYLexBufferUnit('$');

    {PlateCharacter}+ R CYLexBufferUnits(yytext, yyleng);
    {PlateCharacter}*{UnicodeFail} R E("invalid character");
    {LineTerminatorSequence} R E("invalid newline");
}
    /* }}} */
    /* Escapes {{{ */
<LegacySingleString,LegacyDoubleString>{
    \\[0-3][0-7][0-7] R CYLexBufferPoint(X(yytext[1]) << 6 | X(yytext[2]) << 3 | X(yytext[3]));
    \\[0-7][0-7] R CYLexBufferUnit(X(yytext[1]) << 3 | X(yytext[2]));
    \\[0-7] R CYLexBufferUnit(X(yytext[1]));
}

<StrictSingleString,StrictDoubleString,StrictAccentString>{
    \\0[0-7] R E("legacy escape");
    \\0 R CYLexBufferUnit('\0');
}

<LegacySingleString,LegacyDoubleString,StrictSingleString,StrictDoubleString,StrictAccentString>{
    \\b R CYLexBufferUnit('\b');
    \\f R CYLexBufferUnit('\f');
    \\n R CYLexBufferUnit('\n');
    \\r R CYLexBufferUnit('\r');
    \\t R CYLexBufferUnit('\t');
    \\v R CYLexBufferUnit('\v');

    \\x{HexDigit}{2} R CYLexBufferPoint(X(yytext[2]) << 4 | X(yytext[3]));

    \\u{HexDigit}{4} R CYLexBufferPoint(X(yytext[2]) << 12 | X(yytext[3]) << 8 | X(yytext[4]) << 4 | X(yytext[5]));

    \\u\{{HexDigit}+\} R {
        unsigned point(0);
        for (yy_size_t i(3); i != yyleng - 1; ++i)
            point = point << 4 | X(yytext[i]);
        CYLexBufferPoint(point);
    }

    \\{LineTerminatorSequence} yylloc->end.lines();
    \\(.|{NotLineTerminator}) R CYLexBufferUnits(yytext + 1, yyleng - 1);

    \\(x{HexDigit}{0,1}|u({HexDigit}{0,3}|\{{HexDigit}*)|{UnicodeFail})? R E("invalid escape");
    <<EOF>> R E("invalid string");
}
    /* }}} */

{LineTerminatorSequence} yylloc->step(); yylloc->end.lines(); yyextra->last_ = true; N
{WhiteSpace} L

<<EOF>> if (yyextra->auto_) { yyextra->auto_ = false; F(tk::AutoComplete, hi::Nothing); } L yyterminate();

. L E("invalid character")

%%

void CYDriver::ScannerInit() {
    cylex_init(&scanner_);
    cyset_extra(this, scanner_);
}

void CYDriver::ScannerDestroy() {
    cylex_destroy(scanner_);
}

void CYDriver::SetCondition(Condition condition) {
    struct yyguts_t *yyg(reinterpret_cast<struct yyguts_t *>(scanner_));

    switch (condition) {
        case RegExpCondition:
            BEGIN(template_.top() ? RegExpOrTemplateTail : RegExp);
            break;
@begin E4X
        case XMLContentCondition:
            BEGIN(XMLContent);
            break;
        case XMLTagCondition:
            BEGIN(XMLTag);
            break;
@end
        default:
            _assert(false);
    }
}

void CYDriver::PushCondition(Condition condition) {
    switch (condition) {
        case RegExpCondition:
            yy_push_state(RegExp, scanner_);
            break;
@begin E4X
        case XMLContentCondition:
            yy_push_state(XMLContent, scanner_);
            break;
        case XMLTagCondition:
            yy_push_state(XMLTag, scanner_);
            break;
@end
        default:
            _assert(false);
    }
}

void CYDriver::PopCondition() {
    yy_pop_state(scanner_);
}

#if defined(__clang__)
#pragma clang diagnostic pop
#else
// must not pop -Wunused-function
//#pragma GCC diagnostic pop
#endif

/* Cycript - Optimizing JavaScript Compiler/Runtime
 * Copyright (C) 2009-2015  Jay Freeman (saurik)
*/

/* GNU Affero General Public License, Version 3 {{{ */
/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.

 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

%code top {
#define YYSTACKEXPANDABLE 1
}

%code requires {
#include "Driver.hpp"
#include "Parser.hpp"
#include "Stack.hpp"
#define CYNew new(driver.pool_)

@begin ObjectiveC
#include "ObjectiveC/Syntax.hpp"
@end

@begin E4X
#include "E4X/Syntax.hpp"
@end

#include "Highlight.hpp"
}

%union { bool bool_; }

%union { CYMember *access_; }
%union { CYArgument *argument_; }
%union { CYAssignment *assignment_; }
%union { CYBoolean *boolean_; }
%union { CYClause *clause_; }
%union { cy::Syntax::Catch *catch_; }
%union { CYClassTail *classTail_; }
%union { CYComprehension *comprehension_; }
%union { CYDeclaration *declaration_; }
%union { CYDeclarations *declarations_; }
%union { CYElement *element_; }
%union { CYExpression *expression_; }
%union { CYFalse *false_; }
%union { CYVariable *variable_; }
%union { CYFinally *finally_; }
%union { CYForInitializer *for_; }
%union { CYForInInitializer *forin_; }
%union { CYFunctionParameter *functionParameter_; }
%union { CYIdentifier *identifier_; }
%union { CYInfix *infix_; }
%union { CYLiteral *literal_; }
%union { CYMethod *method_; }
%union { CYModule *module_; }
%union { CYNull *null_; }
%union { CYNumber *number_; }
%union { CYParenthetical *parenthetical_; }
%union { CYProperty *property_; }
%union { CYPropertyName *propertyName_; }
%union { CYRubyProc *rubyProc_; }
%union { CYSpan *span_; }
%union { CYStatement *statement_; }
%union { CYString *string_; }
%union { CYTarget *target_; }
%union { CYThis *this_; }
%union { CYTrue *true_; }
%union { CYWord *word_; }

@begin C
%union { CYTypeModifier *modifier_; }
%union { CYTypeSpecifier *specifier_; }
%union { CYTypedIdentifier *typedIdentifier_; }
%union { CYTypedParameter *typedParameter_; }
@end

@begin ObjectiveC
%union { CYMessage *message_; }
%union { CYMessageParameter *messageParameter_; }
%union { CYImplementationField *implementationField_; }
%union { CYProtocol *protocol_; }
%union { CYSelectorPart *selector_; }
@end

@begin E4X
%union { CYAttribute *attribute_; }
%union { CYPropertyIdentifier *propertyIdentifier_; }
%union { CYSelector *selector_; }
@end

%code provides {

struct YYSTYPE {
    cy::parser::semantic_type semantic_;
    hi::Value highlight_;
};

int cylex(YYSTYPE *, CYLocation *, void *);

}

%code {

typedef cy::parser::token tk;

#undef yylex
_finline int yylex(cy::parser::semantic_type *semantic, CYLocation *location, CYDriver &driver) {
    if (driver.mark_ == CYMarkIgnore);
    else if (driver.mark_ == CYMarkScript) {
        driver.mark_ = CYMarkIgnore;
        return cy::parser::token::MarkScript;
    } else if (driver.mark_ == CYMarkModule) {
        driver.mark_ = CYMarkIgnore;
        return cy::parser::token::MarkModule;
    }

  lex:
    if (driver.newline_ == CYDriver::NewLineHere)
        driver.newline_ = CYDriver::NewLineLast;
    else if (driver.newline_ == CYDriver::NewLineLast)
        driver.newline_ = CYDriver::NewLineNone;

    YYSTYPE data;
    int token(cylex(&data, location, driver.scanner_));
    *semantic = data.semantic_;

    switch (token) {
        case tk::_in_:
            if (driver.in_.top())
                token = tk::_in__;
        break;

        case tk::_return_:
            if (driver.return_.top())
                token = tk::_return__;
        break;

        case tk::_yield_:
            if (driver.yield_.top())
                token = tk::_yield__;
        break;

        case tk::EqualRight:
            if (driver.newline_ == CYDriver::NewLineLast)
                token = tk::EqualRight_;
        break;

        case tk::HyphenHyphen:
            if (driver.newline_ == CYDriver::NewLineLast)
                token = tk::HyphenHyphen_;
        break;

        case tk::NewLine:
            driver.newline_ = CYDriver::NewLineHere;
            if (!driver.next_)
                goto lex;
        break;

        case tk::OpenBrace:
            if (driver.newline_ == CYDriver::NewLineLast)
                token = tk::OpenBrace_;
        break;

        case tk::PlusPlus:
            if (driver.newline_ == CYDriver::NewLineLast)
                token = tk::PlusPlus_;
        break;
    }

    driver.next_ = false;
    return token;
}

#define CYLEX() do if (yyla.empty()) { \
    YYCDEBUG << "Mapping a token: "; \
    yyla.type = yytranslate_(yylex(&yyla.value, &yyla.location, driver)); \
    YY_SYMBOL_PRINT("Next token is", yyla); \
} while (false)

#define CYMAP(to, from) do { \
    CYLEX(); \
    if (yyla.type == yytranslate_(token::from)) \
        yyla.type = yytranslate_(token::to); \
} while (false)

#define CYERR(location, message) do { \
    error(location, message); \
    YYABORT; \
} while (false)

#define CYNOT(location) \
    CYERR(location, "unimplemented feature")

}

%name-prefix "cy"

%language "C++"

%initial-action {
    @$.begin.filename = @$.end.filename = &driver.filename_;
};

%locations
%defines

%define api.location.type { CYLocation }

//%glr-parser
//%expect 1

%error-verbose

%param { CYDriver &driver }

/* Token Declarations {{{ */
@begin E4X
%token XMLCDATA
%token XMLComment
%token XMLPI

%token XMLAttributeValue
%token XMLName
%token XMLTagCharacters
%token XMLText
%token XMLWhitespace
@end

@begin E4X
%token LeftRight "<>"
%token LeftSlashRight "</>"

%token SlashRight "/>"
%token LeftSlash "</"

%token ColonColon "::"
%token PeriodPeriod ".."
@end

@begin E4X ObjectiveC
%token At "@"
%token Pound "#"
@end

%token Ampersand "&"
%token AmpersandAmpersand "&&"
%token AmpersandEqual "&="
%token Carrot "^"
%token CarrotEqual "^="
%token Equal "="
%token EqualEqual "=="
%token EqualEqualEqual "==="
%token EqualRight "=>"
%token EqualRight_ "\n=>"
%token Exclamation "!"
%token ExclamationEqual "!="
%token ExclamationEqualEqual "!=="
%token Hyphen "-"
%token HyphenEqual "-="
%token HyphenHyphen "--"
%token HyphenHyphen_ "\n--"
%token HyphenRight "->"
%token Left "<"
%token LeftEqual "<="
%token LeftLeft "<<"
%token LeftLeftEqual "<<="
%token Percent "%"
%token PercentEqual "%="
%token Period "."
%token PeriodPeriodPeriod "..."
%token Pipe "|"
%token PipeEqual "|="
%token PipePipe "||"
%token Plus "+"
%token PlusEqual "+="
%token PlusPlus "++"
%token PlusPlus_ "\n++"
%token Right ">"
%token RightEqual ">="
%token RightRight ">>"
%token RightRightEqual ">>="
%token RightRightRight ">>>"
%token RightRightRightEqual ">>>="
%token Slash "/"
%token SlashEqual "/="
%token Star "*"
%token StarEqual "*="
%token Tilde "~"

%token Colon ":"
%token Comma ","
%token Question "?"
%token SemiColon ";"
%token NewLine "\n"

%token Comment

%token OpenParen "("
%token CloseParen ")"

%token OpenBrace "{"
%token OpenBrace_ "\n{"
%token OpenBrace__ ";{"
%token CloseBrace "}"

%token OpenBracket "["
%token CloseBracket "]"

%token At_error_ "@error"

@begin Java
%token At_class_ "@class"
@end

@begin C
%token _typedef_ "typedef"
%token _unsigned_ "unsigned"
%token _signed_ "signed"
%token _extern_ "extern"
@end

@begin C
%token At_encode_ "@encode"
@end

@begin ObjectiveC
%token At_implementation_ "@implementation"
%token At_import_ "@import"
%token At_end_ "@end"
%token At_selector_ "@selector"
%token At_null_ "@null"
%token At_YES_ "@YES"
%token At_NO_ "@NO"
%token At_true_ "@true"
%token At_false_ "@false"
%token _YES_ "YES"
%token _NO_ "NO"
@end

%token _false_ "false"
%token _null_ "null"
%token _true_ "true"

%token _break_ "break"
%token _case_ "case"
%token _catch_ "catch"
%token _class_ "class"
%token _class__ ";class"
%token _const_ "const"
%token _continue_ "continue"
%token _debugger_ "debugger"
%token _default_ "default"
%token _delete_ "delete"
%token _do_ "do"
%token _else_ "else"
%token _enum_ "enum"
%token _export_ "export"
%token _extends_ "extends"
%token _finally_ "finally"
%token _for_ "for"
%token _function_ "function"
%token _function__ ";function"
%token _if_ "if"
%token _import_ "import"
%token _in_ "in"
%token _in__ "!in"
%token _Infinity_ "Infinity"
%token _instanceof_ "instanceof"
%token _new_ "new"
%token _return_ "return"
%token _return__ "!return"
%token _super_ "super"
%token _switch_ "switch"
%token _target_ "target"
%token _this_ "this"
%token _throw_ "throw"
%token _try_ "try"
%token _typeof_ "typeof"
%token _var_ "var"
%token _void_ "void"
%token _while_ "while"
%token _with_ "with"

%token _abstract_ "abstract"
%token _await_ "await"
%token _boolean_ "boolean"
%token _byte_ "byte"
%token _char_ "char"
%token _constructor_ "constructor"
%token _double_ "double"
%token _eval_ "eval"
%token _final_ "final"
%token _float_ "float"
%token _from_ "from"
%token _get_ "get"
%token _goto_ "goto"
%token _implements_ "implements"
%token _int_ "int"
%token _interface_ "interface"
%token _let_ "let"
%token _long_ "long"
%token _native_ "native"
%token _package_ "package"
%token _private_ "private"
%token _protected_ "protected"
%token _prototype_ "prototype"
%token _public_ "public"
%token _set_ "set"
%token _short_ "short"
%token _static_ "static"
%token _synchronized_ "synchronized"
%token _throws_ "throws"
%token _transient_ "transient"
%token _volatile_ "volatile"
%token _yield_ "yield"
%token _yield__ "!yield"

%token _undefined_ "undefined"

@begin ObjectiveC
%token _bool_ "bool"
%token _BOOL_ "BOOL"
%token _id_ "id"
%token _nil_ "nil"
%token _NULL_ "NULL"
%token _SEL_ "SEL"
@end

%token _auto_ "auto"
%token _each_ "each"
%token _of_ "of"

@begin E4X
%token _namespace_ "namespace"
%token _xml_ "xml"
@end

%token AutoComplete
%token YieldStar

%token <identifier_> Identifier_
%token <number_> NumericLiteral
%token <string_> StringLiteral
%token <literal_> RegularExpressionLiteral

%token <string_> NoSubstitutionTemplate
%token <string_> TemplateHead
%token <string_> TemplateMiddle
%token <string_> TemplateTail

%type <expression_> AdditiveExpression
%type <argument_> ArgumentList_
%type <argument_> ArgumentList
%type <argument_> ArgumentListOpt
%type <argument_> Arguments
%type <target_> ArrayComprehension
%type <literal_> ArrayLiteral
%type <expression_> ArrowFunction
%type <functionParameter_> ArrowParameters
%type <expression_> AssignmentExpression
%type <expression_> AssignmentExpressionOpt
%type <identifier_> BindingIdentifier
%type <identifier_> BindingIdentifierOpt
%type <declarations_> BindingList_
%type <declarations_> BindingList
%type <expression_> BitwiseANDExpression
%type <statement_> Block
%type <statement_> BlockStatement
%type <boolean_> BooleanLiteral
%type <declaration_> BindingElement
%type <expression_> BitwiseORExpression
%type <expression_> BitwiseXORExpression
%type <statement_> BreakStatement
%type <statement_> BreakableStatement
%type <expression_> CallExpression_
%type <target_> CallExpression
%type <clause_> CaseBlock
%type <clause_> CaseClause
%type <clause_> CaseClausesOpt
%type <catch_> Catch
%type <identifier_> CatchParameter
%type <statement_> ClassDeclaration
%type <target_> ClassExpression
%type <classTail_> ClassHeritage
%type <classTail_> ClassHeritageOpt
%type <classTail_> ClassTail
%type <target_> Comprehension
%type <comprehension_> ComprehensionFor
%type <comprehension_> ComprehensionIf
%type <comprehension_> ComprehensionTail
%type <propertyName_> ComputedPropertyName
%type <expression_> ConditionalExpression
%type <statement_> ContinueStatement
%type <statement_> ConciseBody
%type <parenthetical_> CoverParenthesizedExpressionAndArrowParameterList
%type <statement_> DebuggerStatement
%type <statement_> Declaration__
%type <statement_> Declaration_
%type <statement_> Declaration
%type <clause_> DefaultClause
%type <element_> ElementList
%type <element_> ElementListOpt
%type <statement_> ElseStatementOpt
%type <for_> EmptyStatement
%type <expression_> EqualityExpression
%type <expression_> Expression
%type <expression_> ExpressionOpt
%type <for_> ExpressionStatement_
%type <statement_> ExpressionStatement
%type <finally_> Finally
%type <declaration_> ForBinding
%type <forin_> ForDeclaration
%type <forin_> ForInStatementInitializer
%type <for_> ForStatementInitializer
%type <declaration_> FormalParameter
%type <functionParameter_> FormalParameterList_
%type <functionParameter_> FormalParameterList
%type <functionParameter_> FormalParameters
%type <statement_> FunctionBody
%type <statement_> FunctionDeclaration
%type <target_> FunctionExpression
%type <statement_> FunctionStatementList
%type <statement_> GeneratorBody
%type <statement_> GeneratorDeclaration
%type <target_> GeneratorExpression
%type <method_> GeneratorMethod
%type <statement_> HoistableDeclaration
%type <identifier_> Identifier
%type <identifier_> IdentifierType
%type <word_> IdentifierName
%type <variable_> IdentifierReference
%type <statement_> IfStatement
%type <expression_> Initializer
%type <expression_> InitializerOpt
%type <statement_> IterationStatement
%type <identifier_> LabelIdentifier
%type <statement_> LabelledItem
%type <statement_> LabelledStatement
%type <assignment_> LeftHandSideAssignment
%type <target_> LeftHandSideExpression
%type <bool_> LetOrConst
%type <declaration_> LexicalBinding
%type <for_> LexicalDeclaration_
%type <statement_> LexicalDeclaration
%type <literal_> Literal
%type <propertyName_> LiteralPropertyName
%type <expression_> LogicalANDExpression
%type <expression_> LogicalORExpression
%type <access_> MemberAccess
%type <target_> MemberExpression
%type <method_> MethodDefinition
%type <module_> ModulePath
%type <expression_> MultiplicativeExpression
%type <target_> NewExpression
%type <null_> NullLiteral
%type <literal_> ObjectLiteral
%type <expression_> PostfixExpression
%type <target_> PrimaryExpression
%type <propertyName_> PropertyName
%type <property_> PropertyDefinition
%type <property_> PropertyDefinitionList_
%type <property_> PropertyDefinitionList
%type <property_> PropertyDefinitionListOpt
%type <declaration_> PropertySetParameterList
%type <expression_> RelationalExpression
%type <statement_> ReturnStatement
%type <rubyProc_> RubyProcExpression
%type <functionParameter_> RubyProcParameterList_
%type <functionParameter_> RubyProcParameterList
%type <functionParameter_> RubyProcParameters
%type <functionParameter_> RubyProcParametersOpt
%type <statement_> Script
%type <statement_> ScriptBody
%type <statement_> ScriptBodyOpt
%type <expression_> ShiftExpression
%type <declaration_> SingleNameBinding
%type <statement_> Statement__
%type <statement_> Statement_
%type <statement_> Statement
%type <statement_> StatementList
%type <statement_> StatementListOpt
%type <statement_> StatementListItem
%type <functionParameter_> StrictFormalParameters
%type <target_> SuperCall
%type <target_> SuperProperty
%type <statement_> SwitchStatement
%type <target_> TemplateLiteral
%type <span_> TemplateSpans
%type <statement_> ThrowStatement
%type <statement_> TryStatement
%type <expression_> UnaryExpression_
%type <expression_> UnaryExpression
%type <declaration_> VariableDeclaration
%type <declarations_> VariableDeclarationList_
%type <declarations_> VariableDeclarationList
%type <for_> VariableStatement_
%type <statement_> VariableStatement
%type <statement_> WithStatement
%type <word_> Word
@begin ObjectiveC
%type <word_> WordOpt
@end
%type <expression_> YieldExpression

@begin C
%type <specifier_> IntegerType
%type <specifier_> IntegerTypeOpt
%type <typedIdentifier_> PrefixedType
%type <specifier_> PrimitiveType
%type <typedIdentifier_> SuffixedType
%type <typedIdentifier_> TypeSignifier
%type <modifier_> TypeQualifierLeft
%type <typedIdentifier_> TypeQualifierRight
%type <typedIdentifier_> TypedIdentifier
%type <typedParameter_> TypedParameterList_
%type <typedParameter_> TypedParameterList
%type <typedParameter_> TypedParameterListOpt
@end

@begin ObjectiveC
%type <expression_> AssignmentExpressionClassic
%type <expression_> BoxableExpression
%type <statement_> CategoryStatement
%type <expression_> ClassSuperOpt
%type <expression_> ConditionalExpressionClassic
%type <implementationField_> ImplementationFieldListOpt
%type <implementationField_> ImplementationFields
%type <message_> ClassMessageDeclaration
%type <message_> ClassMessageDeclarationListOpt
%type <protocol_> ClassProtocolListOpt
%type <protocol_> ClassProtocols
%type <protocol_> ClassProtocolsOpt
%type <statement_> ImplementationStatement
%type <target_> MessageExpression
%type <messageParameter_> MessageParameter
%type <messageParameter_> MessageParameters
%type <messageParameter_> MessageParameterList
%type <messageParameter_> MessageParameterListOpt
%type <bool_> MessageScope
%type <argument_> SelectorCall_
%type <argument_> SelectorCall
%type <selector_> SelectorExpression_
%type <selector_> SelectorExpression
%type <selector_> SelectorExpressionOpt
%type <argument_> SelectorList
%type <word_> SelectorWordOpt
%type <typedIdentifier_> TypeOpt
%type <argument_> VariadicCall
@end

@begin E4X
%type <propertyIdentifier_> PropertyIdentifier_
%type <selector_> PropertySelector_
%type <selector_> PropertySelector
%type <identifier_> QualifiedIdentifier_
%type <identifier_> QualifiedIdentifier
%type <identifier_> WildcardIdentifier
%type <identifier_> XMLComment
%type <identifier_> XMLCDATA
%type <identifier_> XMLElement
%type <identifier_> XMLElementContent
%type <identifier_> XMLMarkup
%type <identifier_> XMLPI

%type <attribute_> AttributeIdentifier
/* XXX: %type <statement_> DefaultXMLNamespaceStatement */
%type <expression_> PropertyIdentifier
%type <expression_> XMLListInitialiser
%type <expression_> XMLInitialiser
@end
/* }}} */
/* Token Priorities {{{ */
%nonassoc ""
%left "++" "--" "{"

%nonassoc "if"
%nonassoc "else"
/* }}} */

%start Program
%token MarkModule
%token MarkScript

%%

Program
    : MarkScript Script
    | MarkModule Module
    ;

/* Lexer State {{{ */
LexPushInOn: { driver.in_.push(true); };
LexPushInOff: { driver.in_.push(false); };
LexPopIn: { driver.in_.pop(); };

LexPushReturnOn: { driver.return_.push(true); };
LexPopReturn: { driver.return_.pop(); };

LexPushSuperOn: { driver.super_.push(true); };
LexPushSuperOff: { driver.super_.push(false); };
LexPopSuper: { driver.super_.pop(); };

LexPushYieldOn: { driver.yield_.push(true); };
LexPushYieldOff: { driver.yield_.push(false); };
LexPopYield: { driver.yield_.pop(); };

LexSetRegExp
    : { CYLEX(); if (yyla.type == yytranslate_(token::Slash)) { yyla.clear(); driver.SetRegEx(false); } else if (yyla.type == yytranslate_(token::SlashEqual)) { yyla.clear(); driver.SetRegEx(true); } }
    ;

LexNewLine
    : { if (!yyla.empty() && yyla.type_get() != yyeof_) CYERR(@$, "unexpected lookahead"); driver.next_ = true; }
    ;

LexNoStar
    : { CYMAP(YieldStar, Star); }
    ;

LexNoBrace
    : { CYMAP(OpenBrace__, OpenBrace); CYMAP(OpenBrace__, OpenBrace_); }
    ;

LexNoClass
    : { CYMAP(_class__, _class_); }
    ;

LexNoFunction
    : { CYMAP(_function__, _function_); }
    ;

LexSetStatement
    : LexNoBrace LexNoClass LexNoFunction
    ;
/* }}} */
/* Virtual Tokens {{{ */
BRACE
    : "{"
    | "\n{"
    ;

Var_
    : "var"
    ;
/* }}} */

/* 11.6 Names and Keywords {{{ */
IdentifierName
    : Word { $$ = $1; }
    | "for" { $$ = CYNew CYWord("for"); }
    | "in" { $$ = CYNew CYWord("in"); }
    | "instanceof" { $$ = CYNew CYWord("instanceof"); }
    ;

NewLineOpt
    : "\n"
    |
    ;

Word
    : Identifier { $$ = $1; }
    | "auto" { $$ = CYNew CYWord("auto"); }
    | "break" { $$ = CYNew CYWord("break"); }
    | "case" { $$ = CYNew CYWord("case"); }
    | "catch" { $$ = CYNew CYWord("catch"); }
    | "class" { $$ = CYNew CYWord("class"); }
    | ";class" { $$ = CYNew CYWord("class"); }
    | "const" { $$ = CYNew CYWord("const"); }
    | "continue" { $$ = CYNew CYWord("continue"); }
    | "debugger" { $$ = CYNew CYWord("debugger"); }
    | "default" { $$ = CYNew CYWord("default"); }
    | "delete" LexSetRegExp { $$ = CYNew CYWord("delete"); }
    | "do" { $$ = CYNew CYWord("do"); }
    | "else" { $$ = CYNew CYWord("else"); }
    | "enum" { $$ = CYNew CYWord("enum"); }
    | "export" { $$ = CYNew CYWord("export"); }
    | "extends" { $$ = CYNew CYWord("extends"); }
    | "false" { $$ = CYNew CYWord("false"); }
    | "finally" { $$ = CYNew CYWord("finally"); }
    | "function" { $$ = CYNew CYWord("function"); }
    | "if" { $$ = CYNew CYWord("if"); }
    | "import" { $$ = CYNew CYWord("import"); }
    | "!in" { $$ = CYNew CYWord("in"); }
    | "new" LexSetRegExp { $$ = CYNew CYWord("new"); }
    | "null" { $$ = CYNew CYWord("null"); }
    | "return" { $$ = CYNew CYWord("return"); }
    | "!return" { $$ = CYNew CYWord("return"); }
    | "super" { $$ = CYNew CYWord("super"); }
    | "switch" { $$ = CYNew CYWord("switch"); }
    | "this" { $$ = CYNew CYWord("this"); }
    | "throw" { $$ = CYNew CYWord("throw"); }
    | "true" { $$ = CYNew CYWord("true"); }
    | "try" { $$ = CYNew CYWord("try"); }
    | "typeof" LexSetRegExp { $$ = CYNew CYWord("typeof"); }
    | "var" { $$ = CYNew CYWord("var"); }
    | "void" LexSetRegExp { $$ = CYNew CYWord("void"); }
    | "while" { $$ = CYNew CYWord("while"); }
    | "with" { $$ = CYNew CYWord("with"); }
    | "yield" { $$ = CYNew CYIdentifier("yield"); }

    | Yield LexSetRegExp NewLineOpt { $$ = CYNew CYIdentifier("yield"); }

    // XXX: should be Identifier
    | "let" { $$ = CYNew CYIdentifier("let"); }
    ;

@begin ObjectiveC
WordOpt
    : Word { $$ = $1; }
    | { $$ = NULL; }
    ;
@end
/* }}} */
/* 11.8.1 Null Literals {{{ */
NullLiteral
    : "null" { $$ = CYNew CYNull(); }
    ;
/* }}} */
/* 11.8.2 Boolean Literals {{{ */
BooleanLiteral
    : "true" { $$ = CYNew CYTrue(); }
    | "false" { $$ = CYNew CYFalse(); }
    ;
/* }}} */

/* 11.9 Automatic Semicolon Insertion {{{ */
StrictSemi
    : { driver.Warning(@$, "warning, automatic semi-colon insertion required"); }
    ;

TerminatorSoft
    : ";"
    | "\n" StrictSemi
    ;

Terminator
    : ";"
    | error { if (yyla.type_get() != yyeof_ && yyla.type != yytranslate_(token::CloseBrace) && driver.newline_ == CYDriver::NewLineNone) { CYERR(@1, "required semi-colon"); } else { yyerrok; driver.errors_.pop_back(); } } StrictSemi
    ;

TerminatorOpt
    : ";"
    | error { yyerrok; driver.errors_.pop_back(); } StrictSemi
    ;
/* }}} */

/* 12.1 Identifiers {{{ */
IdentifierReference
    : Identifier { $$ = CYNew CYVariable($1); }
    | "yield" { $$ = CYNew CYVariable(CYNew CYIdentifier("yield")); }
    ;

BindingIdentifier
    : Identifier { $$ = $1; }
    | "yield" { $$ = CYNew CYIdentifier("yield"); }
    ;

BindingIdentifierOpt
    : BindingIdentifier { $$ = $1; }
    | { $$ = NULL; }
    ;

LabelIdentifier
    : Identifier { $$ = $1; }
    | "yield" { $$ = CYNew CYIdentifier("yield"); }
    ;

IdentifierType
    : Identifier_ { $$ = $1; }
    | "abstract" { $$ = CYNew CYIdentifier("abstract"); }
    | "await" { $$ = CYNew CYIdentifier("await"); }
    | "boolean" { $$ = CYNew CYIdentifier("boolean"); }
    | "byte" { $$ = CYNew CYIdentifier("byte"); }
    | "constructor" { $$ = CYNew CYIdentifier("constructor"); }
    | "double" { $$ = CYNew CYIdentifier("double"); }
    | "each" { $$ = CYNew CYIdentifier("each"); }
    | "eval" { $$ = CYNew CYIdentifier("eval"); }
    | "final" { $$ = CYNew CYIdentifier("final"); }
    | "float" { $$ = CYNew CYIdentifier("float"); }
    | "from" { $$ = CYNew CYIdentifier("from"); }
    | "get" { $$ = CYNew CYIdentifier("get"); }
    | "goto" { $$ = CYNew CYIdentifier("goto"); }
    | "implements" { $$ = CYNew CYIdentifier("implements"); }
    | "Infinity" { $$ = CYNew CYIdentifier("Infinity"); }
    | "interface" { $$ = CYNew CYIdentifier("interface"); }
    | "native" { $$ = CYNew CYIdentifier("native"); }
    | "of" { $$ = CYNew CYIdentifier("of"); }
    | "package" { $$ = CYNew CYIdentifier("package"); }
    | "private" { $$ = CYNew CYIdentifier("private"); }
    | "protected" { $$ = CYNew CYIdentifier("protected"); }
    | "prototype" { $$ = CYNew CYIdentifier("prototype"); }
    | "public" { $$ = CYNew CYIdentifier("public"); }
    | "set" { $$ = CYNew CYIdentifier("set"); }
    | "synchronized" { $$ = CYNew CYIdentifier("synchronized"); }
    | "target" { $$ = CYNew CYIdentifier("target"); }
    | "throws" { $$ = CYNew CYIdentifier("throws"); }
    | "transient" { $$ = CYNew CYIdentifier("transient"); }
    | "undefined" { $$ = CYNew CYIdentifier("undefined"); }
@begin ObjectiveC
    | "bool" { $$ = CYNew CYIdentifier("bool"); }
    | "BOOL" { $$ = CYNew CYIdentifier("BOOL"); }
    | "id" { $$ = CYNew CYIdentifier("id"); }
    | "SEL" { $$ = CYNew CYIdentifier("SEL"); }
@end
    ;

Identifier
    : IdentifierType
    | "char" { $$ = CYNew CYIdentifier("char"); }
    | "int" { $$ = CYNew CYIdentifier("int"); }
    | "long" { $$ = CYNew CYIdentifier("long"); }
    | "short" { $$ = CYNew CYIdentifier("short"); }
    | "static" { $$ = CYNew CYIdentifier("static"); }
    | "volatile" { $$ = CYNew CYIdentifier("volatile"); }
@begin C
    | "extern" { $$ = CYNew CYIdentifier("extern"); }
    | "signed" { $$ = CYNew CYIdentifier("signed"); }
    | "typedef" { $$ = CYNew CYIdentifier("typedef"); }
    | "unsigned" { $$ = CYNew CYIdentifier("unsigned"); }
@end
@begin ObjectiveC
    | "nil" { $$ = CYNew CYIdentifier("nil"); }
    | "NO" { $$ = CYNew CYIdentifier("NO"); }
    | "NULL" { $$ = CYNew CYIdentifier("NULL"); }
    | "YES" { $$ = CYNew CYIdentifier("YES"); }
@end
    ;
/* }}} */
/* 12.2 Primary Expression {{{ */
PrimaryExpression
    : "this" { $$ = CYNew CYThis(); }
    | IdentifierReference { $$ = $1; }
    | Literal { $$ = $1; }
    | ArrayLiteral { $$ = $1; }
    | ObjectLiteral { $$ = $1; }
    | FunctionExpression { $$ = $1; }
    | ClassExpression { $$ = $1; }
    | GeneratorExpression { $$ = $1; }
    | RegularExpressionLiteral { $$ = $1; }
    | TemplateLiteral { $$ = $1; }
    | CoverParenthesizedExpressionAndArrowParameterList { if ($1 == NULL) CYERR(@1, "invalid parenthetical"); $$ = $1; }
    | AutoComplete { driver.mode_ = CYDriver::AutoPrimary; YYACCEPT; }
    ;

CoverParenthesizedExpressionAndArrowParameterList
    : "(" LexPushInOff Expression ")" LexPopIn { $$ = CYNew CYParenthetical($3); }
    | "(" LexPushInOff LexSetRegExp ")" LexPopIn { $$ = NULL; }
    | "(" LexPushInOff LexSetRegExp "..." BindingIdentifier ")" LexPopIn { CYNOT(@$); }
    | "(" LexPushInOff Expression "," LexSetRegExp "..." BindingIdentifier ")" LexPopIn { CYNOT(@$); }
    ;
/* }}} */
/* 12.2.4 Literals {{{ */
Literal
    : NullLiteral { $$ = $1; }
    | BooleanLiteral { $$ = $1; }
    | NumericLiteral { $$ = $1; }
    | StringLiteral { $$ = $1; }
    ;
/* }}} */
/* 12.2.5 Array Initializer {{{ */
ArrayLiteral
    : "[" LexPushInOff ElementListOpt "]" LexPopIn { $$ = CYNew CYArray($3); }
    ;

ElementList
    : AssignmentExpressionOpt "," ElementListOpt { $$ = CYNew CYElementValue($1, $3); }
    | LexSetRegExp "..." AssignmentExpression { $$ = CYNew CYElementSpread($3); }
    | AssignmentExpression { $$ = CYNew CYElementValue($1, NULL); }
    ;

ElementListOpt
    : ElementList { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;
/* }}} */
/* 12.2.6 Object Initializer {{{ */
ObjectLiteral
    : BRACE LexPushInOff PropertyDefinitionListOpt "}" LexPopIn { $$ = CYNew CYObject($3); }
    ;

PropertyDefinitionList_
    : "," PropertyDefinitionListOpt { $$ = $2; }
    | { $$ = NULL; }
    ;

PropertyDefinitionList
    : PropertyDefinition PropertyDefinitionList_ { $1->SetNext($2); $$ = $1; }
    ;

PropertyDefinitionListOpt
    : LexSetRegExp PropertyDefinitionList { $$ = $2; }
    | LexSetRegExp { $$ = NULL; }
    ;

PropertyDefinition
    : IdentifierReference { $$ = CYNew CYPropertyValue($1->name_, $1); }
    | CoverInitializedName { CYNOT(@$); }
    | PropertyName ":" AssignmentExpression { $$ = CYNew CYPropertyValue($1, $3); }
    | MethodDefinition { $$ = $1; }
    ;

PropertyName
    : LiteralPropertyName { $$ = $1; }
    | ComputedPropertyName { $$ = $1; }
    ;

LiteralPropertyName
    : IdentifierName { $$ = $1; }
    | StringLiteral { $$ = $1; }
    | NumericLiteral { $$ = $1; }
    ;

ComputedPropertyName
    : "[" AssignmentExpression "]" { $$ = CYNew CYComputed($2); }
    ;

CoverInitializedName
    : IdentifierReference Initializer
    ;

Initializer
    : "=" AssignmentExpression { $$ = $2; }
    ;

InitializerOpt
    : Initializer { $$ = $1; }
    | { $$ = NULL; }
    ;
/* }}} */
/* 12.2.9 Template Literals {{{ */
TemplateLiteral
    : NoSubstitutionTemplate { $$ = CYNew CYTemplate($1, NULL); }
    | TemplateHead TemplateSpans { $$ = CYNew CYTemplate($1, $2); }
    ;

TemplateSpans
    : Expression TemplateMiddle TemplateSpans { $$ = CYNew CYSpan($1, $2, $3); }
    | Expression TemplateTail { $$ = CYNew CYSpan($1, $2, NULL); }
    ;
/* }}} */

/* 12.3 Left-Hand-Side Expressions {{{ */
MemberAccess
    : "[" LexPushInOff Expression "]" LexPopIn { $$ = CYNew CYDirectMember(NULL, $3); }
    | "." IdentifierName { $$ = CYNew CYDirectMember(NULL, CYNew CYString($2)); }
    | "." AutoComplete { driver.mode_ = CYDriver::AutoDirect; YYACCEPT; }
    | TemplateLiteral { CYNOT(@$); }
    ;

MemberExpression
    : LexSetRegExp PrimaryExpression { $$ = $2; }
    | MemberExpression { driver.context_ = $1; } MemberAccess { $3->SetLeft($1); $$ = $3; }
    | SuperProperty { $$ = $1; }
    | MetaProperty { CYNOT(@$); }
    | LexSetRegExp "new" MemberExpression Arguments { $$ = CYNew cy::Syntax::New($3, $4); }
    ;

SuperProperty
    : LexSetRegExp "super" { if (!driver.super_.top()) CYERR(@2, "invalid super"); } "[" Expression "]" { $$ = CYNew CYSuperAccess($5); }
    | LexSetRegExp "super" { if (!driver.super_.top()) CYERR(@2, "invalid super"); } "." IdentifierName { $$ = CYNew CYSuperAccess(CYNew CYString($5)); }
    ;

MetaProperty
    : NewTarget
    ;

NewTarget
    : LexSetRegExp "new" LexSetRegExp "." "target"
    ;

NewExpression
    : MemberExpression { $$ = $1; }
    | LexSetRegExp "new" NewExpression { $$ = CYNew cy::Syntax::New($3, NULL); }
    ;

CallExpression_
    : MemberExpression { $$ = $1; }
    | CallExpression { $$ = $1; }
    ;

CallExpression
    : CallExpression_ Arguments { if (!$1->Eval()) $$ = CYNew CYCall($1, $2); else $$ = CYNew CYEval($2); }
    | SuperCall { $$ = $1; }
    | CallExpression { driver.context_ = $1; } MemberAccess { $3->SetLeft($1); $$ = $3; }
    ;

SuperCall
    : LexSetRegExp "super" { if (!driver.super_.top()) CYERR(@2, "invalid super"); } Arguments { $$ = CYNew CYSuperCall($4); }
    ;

Arguments
    : "(" LexPushInOff ArgumentListOpt ")" LexPopIn { $$ = $3; }
    ;

ArgumentList_
    : "," ArgumentList { $$ = $2; }
    | { $$ = NULL; }
    ;

ArgumentList
    : AssignmentExpression ArgumentList_ { $$ = CYNew CYArgument(NULL, $1, $2); }
    | LexSetRegExp "..." AssignmentExpression { CYNOT(@$); }
    ;

ArgumentListOpt
    : ArgumentList { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;

LeftHandSideExpression
    : NewExpression { $$ = $1; }
    | CallExpression { $$ = $1; }
    ;
/* }}} */
/* 12.4 Postfix Expressions {{{ */
PostfixExpression
    : %prec "" LeftHandSideExpression { $$ = $1; }
    | LeftHandSideExpression "++" { $$ = CYNew CYPostIncrement($1); }
    | LeftHandSideExpression "--" { $$ = CYNew CYPostDecrement($1); }
    ;
/* }}} */
/* 12.5 Unary Operators {{{ */
UnaryExpression_
    : "delete" UnaryExpression { $$ = CYNew CYDelete($2); }
    | "void" UnaryExpression { $$ = CYNew CYVoid($2); }
    | "typeof" UnaryExpression { $$ = CYNew CYTypeOf($2); }
    | "++" UnaryExpression { $$ = CYNew CYPreIncrement($2); }
    | "\n++" UnaryExpression { $$ = CYNew CYPreIncrement($2); }
    | "--" UnaryExpression { $$ = CYNew CYPreDecrement($2); }
    | "\n--" UnaryExpression { $$ = CYNew CYPreDecrement($2); }
    | "+" UnaryExpression { $$ = CYNew CYAffirm($2); }
    | "-" UnaryExpression { $$ = CYNew CYNegate($2); }
    | "~" UnaryExpression { $$ = CYNew CYBitwiseNot($2); }
    | "!" UnaryExpression { $$ = CYNew CYLogicalNot($2); }
    ;

UnaryExpression
    : %prec "" PostfixExpression { $$ = $1; }
    | LexSetRegExp UnaryExpression_ { $$ = $2; }
    ;
/* }}} */
/* 12.6 Multiplicative Operators {{{ */
MultiplicativeExpression
    : UnaryExpression { $$ = $1; }
    | MultiplicativeExpression "*" UnaryExpression { $$ = CYNew CYMultiply($1, $3); }
    | MultiplicativeExpression "/" UnaryExpression { $$ = CYNew CYDivide($1, $3); }
    | MultiplicativeExpression "%" UnaryExpression { $$ = CYNew CYModulus($1, $3); }
    ;
/* }}} */
/* 12.7 Additive Operators {{{ */
AdditiveExpression
    : MultiplicativeExpression { $$ = $1; }
    | AdditiveExpression "+" MultiplicativeExpression { $$ = CYNew CYAdd($1, $3); }
    | AdditiveExpression "-" MultiplicativeExpression { $$ = CYNew CYSubtract($1, $3); }
    ;
/* }}} */
/* 12.8 Bitwise Shift Operators {{{ */
ShiftExpression
    : AdditiveExpression { $$ = $1; }
    | ShiftExpression "<<" AdditiveExpression { $$ = CYNew CYShiftLeft($1, $3); }
    | ShiftExpression ">>" AdditiveExpression { $$ = CYNew CYShiftRightSigned($1, $3); }
    | ShiftExpression ">>>" AdditiveExpression { $$ = CYNew CYShiftRightUnsigned($1, $3); }
    ;
/* }}} */
/* 12.9 Relational Operators {{{ */
RelationalExpression
    : ShiftExpression { $$ = $1; }
    | RelationalExpression "<" ShiftExpression { $$ = CYNew CYLess($1, $3); }
    | RelationalExpression ">" ShiftExpression { $$ = CYNew CYGreater($1, $3); }
    | RelationalExpression "<=" ShiftExpression { $$ = CYNew CYLessOrEqual($1, $3); }
    | RelationalExpression ">=" ShiftExpression { $$ = CYNew CYGreaterOrEqual($1, $3); }
    | RelationalExpression "instanceof" ShiftExpression { $$ = CYNew CYInstanceOf($1, $3); }
    | RelationalExpression "in" ShiftExpression { $$ = CYNew CYIn($1, $3); }
    ;
/* }}} */
/* 12.10 Equality Operators {{{ */
EqualityExpression
    : RelationalExpression { $$ = $1; }
    | EqualityExpression "==" RelationalExpression { $$ = CYNew CYEqual($1, $3); }
    | EqualityExpression "!=" RelationalExpression { $$ = CYNew CYNotEqual($1, $3); }
    | EqualityExpression "===" RelationalExpression { $$ = CYNew CYIdentical($1, $3); }
    | EqualityExpression "!==" RelationalExpression { $$ = CYNew CYNotIdentical($1, $3); }
    ;
/* }}} */
/* 12.11 Binary Bitwise Operators {{{ */
BitwiseANDExpression
    : EqualityExpression { $$ = $1; }
    | BitwiseANDExpression "&" EqualityExpression { $$ = CYNew CYBitwiseAnd($1, $3); }
    ;

BitwiseXORExpression
    : BitwiseANDExpression { $$ = $1; }
    | BitwiseXORExpression "^" BitwiseANDExpression { $$ = CYNew CYBitwiseXOr($1, $3); }
    ;

BitwiseORExpression
    : BitwiseXORExpression { $$ = $1; }
    | BitwiseORExpression "|" BitwiseXORExpression { $$ = CYNew CYBitwiseOr($1, $3); }
    ;
/* }}} */
/* 12.12 Binary Logical Operators {{{ */
LogicalANDExpression
    : BitwiseORExpression { $$ = $1; }
    | LogicalANDExpression "&&" BitwiseORExpression { $$ = CYNew CYLogicalAnd($1, $3); }
    ;

LogicalORExpression
    : LogicalANDExpression { $$ = $1; }
    | LogicalORExpression "||" LogicalANDExpression { $$ = CYNew CYLogicalOr($1, $3); }
    ;
/* }}} */
/* 12.13 Conditional Operator ( ? : ) {{{ */
@begin ObjectiveC
ConditionalExpressionClassic
    : LogicalORExpression { $$ = $1; }
    | LogicalORExpression "?" LexPushInOff AssignmentExpression ":" LexPopIn AssignmentExpressionClassic { $$ = CYNew CYCondition($1, $4, $7); }
    ;
@end

ConditionalExpression
    : LogicalORExpression { $$ = $1; }
    | LogicalORExpression "?" LexPushInOff AssignmentExpression ":" LexPopIn AssignmentExpression { $$ = CYNew CYCondition($1, $4, $7); }
    ;
/* }}} */
/* 12.14 Assignment Operators {{{ */
LeftHandSideAssignment
    : LeftHandSideExpression "=" { $$ = CYNew CYAssign($1, NULL); }
    | LeftHandSideExpression "*=" { $$ = CYNew CYMultiplyAssign($1, NULL); }
    | LeftHandSideExpression "/=" { $$ = CYNew CYDivideAssign($1, NULL); }
    | LeftHandSideExpression "%=" { $$ = CYNew CYModulusAssign($1, NULL); }
    | LeftHandSideExpression "+=" { $$ = CYNew CYAddAssign($1, NULL); }
    | LeftHandSideExpression "-=" { $$ = CYNew CYSubtractAssign($1, NULL); }
    | LeftHandSideExpression "<<=" { $$ = CYNew CYShiftLeftAssign($1, NULL); }
    | LeftHandSideExpression ">>=" { $$ = CYNew CYShiftRightSignedAssign($1, NULL); }
    | LeftHandSideExpression ">>>=" { $$ = CYNew CYShiftRightUnsignedAssign($1, NULL); }
    | LeftHandSideExpression "&=" { $$ = CYNew CYBitwiseAndAssign($1, NULL); }
    | LeftHandSideExpression "^=" { $$ = CYNew CYBitwiseXOrAssign($1, NULL); }
    | LeftHandSideExpression "|=" { $$ = CYNew CYBitwiseOrAssign($1, NULL); }
    ;

@begin ObjectiveC
AssignmentExpressionClassic
    : ConditionalExpressionClassic { $$ = $1; }
    | LeftHandSideAssignment AssignmentExpressionClassic { $1->SetRight($2); $$ = $1; }
    ;
@end

AssignmentExpression
    : ConditionalExpression { $$ = $1; }
    | LexSetRegExp YieldExpression { $$ = $2; }
    | ArrowFunction { $$ = $1; }
    | LeftHandSideAssignment AssignmentExpression { $1->SetRight($2); $$ = $1; }
    ;

AssignmentExpressionOpt
    : AssignmentExpression { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;
/* }}} */
/* 12.15 Comma Operator ( , ) {{{ */
Expression
    : AssignmentExpression { $$ = $1; }
    | Expression "," AssignmentExpression { $$ = CYNew CYCompound($1, $3); }
    ;

ExpressionOpt
    : Expression { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;
/* }}} */

/* 13 Statements and Declarations {{{ */
Statement__
    : BlockStatement { $$ = $1; }
    | VariableStatement { $$ = $1; }
    | EmptyStatement { $$ = $1; }
    | IfStatement { $$ = $1; }
    | BreakableStatement { $$ = $1; }
    | ContinueStatement { $$ = $1; }
    | BreakStatement { $$ = $1; }
    | ReturnStatement { $$ = $1; }
    | WithStatement { $$ = $1; }
    | LabelledStatement { $$ = $1; }
    | ThrowStatement { $$ = $1; }
    | TryStatement { $$ = $1; }
    | DebuggerStatement { $$ = $1; }
    ;

Statement_
    : LexSetRegExp Statement__ { $$ = $2; }
    | ExpressionStatement { $$ = $1; }
    ;

Statement
    : LexSetStatement Statement_ { $$ = $2; }
    ;

Declaration__
    : HoistableDeclaration { $$ = $1; }
    | ClassDeclaration { $$ = $1; }
    | LexicalDeclaration { $$ = $1; }
    ;

Declaration_
    : LexSetRegExp Declaration__ { $$ = $2; }
    ;

Declaration
    : LexSetStatement Declaration_ { $$ = $2; }
    ;

HoistableDeclaration
    : FunctionDeclaration { $$ = $1; }
    | GeneratorDeclaration { $$ = $1; }
    ;

BreakableStatement
    : IterationStatement { $$ = $1; }
    | SwitchStatement { $$ = $1; }
    ;
/* }}} */
/* 13.2 Block {{{ */
BlockStatement
    : ";{" StatementListOpt "}" { $$ = CYNew CYBlock($2); }
    ;

Block
    : BRACE StatementListOpt "}" { $$ = $2; }
    ;

StatementList
    : StatementListItem StatementListOpt { $1->SetNext($2); $$ = $1; }
    ;

StatementListOpt
    : StatementList { $$ = $1; }
    | LexSetStatement LexSetRegExp { $$ = NULL; }
    ;

StatementListItem
    : Statement { $$ = $1; }
    | Declaration { $$ = $1; }
    ;
/* }}} */
/* 13.3 Let and Const Declarations {{{ */
LexicalDeclaration_
    : LetOrConst BindingList { $$ = CYNew CYLet($1, $2); }
    ;

LexicalDeclaration
    : LexicalDeclaration_ Terminator { $$ = $1; }
    ;

LetOrConst
    : "let" { $$ = false; }
    | "const" { $$ = true; }
    ;

BindingList_
    : "," BindingList { $$ = $2; }
    | { $$ = NULL; }
    ;

BindingList
    : LexicalBinding BindingList_ { $$ = CYNew CYDeclarations($1, $2); }
    ;

LexicalBinding
    : BindingIdentifier InitializerOpt { $$ = CYNew CYDeclaration($1, $2); }
    | BindingPattern Initializer { CYNOT(@1); }
    ;
/* }}} */
/* 13.3.2 Variable Statement {{{ */
VariableStatement_
    : Var_ VariableDeclarationList { $$ = CYNew CYVar($2); }
    ;

VariableStatement
    : VariableStatement_ Terminator { $$ = $1; }
    ;

VariableDeclarationList_
    : "," VariableDeclarationList { $$ = $2; }
    | { $$ = NULL; }
    ;

VariableDeclarationList
    : VariableDeclaration VariableDeclarationList_ { $$ = CYNew CYDeclarations($1, $2); }
    ;

VariableDeclaration
    : BindingIdentifier InitializerOpt { $$ = CYNew CYDeclaration($1, $2); }
    | BindingPattern Initializer { CYNOT(@1); }
    ;
/* }}} */
/* 13.3.3 Destructuring Binding Patterns {{{ */
BindingPattern
    : ObjectBindingPattern
    | ArrayBindingPattern
    ;

ObjectBindingPattern
    : BRACE BindingPropertyListOpt "}"
    ;

ArrayBindingPattern
    : "[" { CYNOT(@$); }
    ;

BindingPropertyList_
    : "," BindingPropertyListOpt
    |
    ;

BindingPropertyList
    : BindingProperty BindingPropertyList_
    ;

BindingPropertyListOpt
    : BindingPropertyList
    |
    ;

BindingProperty
    : SingleNameBinding
    | PropertyName ":" BindingElement
    ;

BindingElement
    : SingleNameBinding { $$ = $1; }
    | BindingPattern InitializerOpt { CYNOT(@$); }
    ;

SingleNameBinding
    : BindingIdentifier InitializerOpt { $$ = CYNew CYDeclaration($1, $2); }
    ;

BindingRestElement
    : "..." BindingIdentifier
    ;
/* }}} */
/* 13.4 Empty Statement {{{ */
EmptyStatement
    : ";" { $$ = CYNew CYEmpty(); }
    ;
/* }}} */
/* 13.5 Expression Statement {{{ */
ExpressionStatement_
    : Expression { $$ = CYNew CYExpress($1); }

ExpressionStatement
    : ExpressionStatement_ Terminator { $$ = $1; }
    ;
/* }}} */
/* 13.6 The if Statement {{{ */
ElseStatementOpt
    : "else" Statement { $$ = $2; }
    | %prec "if" { $$ = NULL; }
    ;

IfStatement
    : "if" "(" Expression ")" Statement ElseStatementOpt { $$ = CYNew CYIf($3, $5, $6); }
    ;
/* }}} */
/* 13.7 Iteration Statements {{{ */
IterationStatement
    : "do" Statement "while" "(" Expression ")" TerminatorOpt { $$ = CYNew CYDoWhile($5, $2); }
    | "while" "(" Expression ")" Statement { $$ = CYNew CYWhile($3, $5); }
    | "for" "(" LexPushInOn ForStatementInitializer LexPopIn ExpressionOpt ";" ExpressionOpt ")" Statement { $$ = CYNew CYFor($4, $6, $8, $10); }
    | "for" "(" LexPushInOn LexSetRegExp Var_ BindingIdentifier Initializer "!in" LexPopIn Expression ")" Statement { $$ = CYNew CYForInitialized(CYNew CYDeclaration($6, $7), $10, $12); }
    | "for" "(" LexPushInOn ForInStatementInitializer "!in" LexPopIn Expression ")" Statement { $$ = CYNew CYForIn($4, $7, $9); }
    | "for" "(" LexPushInOn ForInStatementInitializer "of" LexPopIn AssignmentExpression ")" Statement { $$ = CYNew CYForOf($4, $7, $9); }
    ;

ForStatementInitializer
    : LexSetRegExp EmptyStatement { $$ = $2; }
    | ExpressionStatement_ ";" { $$ = $1; }
    | LexSetRegExp VariableStatement_ ";" { $$ = $2; }
    | LexSetRegExp LexicalDeclaration_ ";" { $$ = $2; }
    ;

ForInStatementInitializer
    : LeftHandSideExpression { $$ = $1; }
    | LexSetRegExp Var_ ForBinding { $$ = CYNew CYForVariable($3); }
    | LexSetRegExp ForDeclaration { $$ = $2; }
    ;

ForDeclaration
    : LetOrConst ForBinding { $$ = CYNew CYForLexical($1, $2); }
    ;

ForBinding
    : BindingIdentifier { $$ = CYNew CYDeclaration($1, NULL); }
    | BindingPattern { CYNOT(@1); }
    ;
/* }}} */
/* 13.8 The continue Statement {{{ */
Continue
    : "continue" LexNewLine
    ;

ContinueStatement
    : Continue TerminatorSoft { $$ = CYNew CYContinue(NULL); }
    | Continue Identifier Terminator { $$ = CYNew CYContinue($2); }
    ;
/* }}} */
/* 13.9 The break Statement {{{ */
Break
    : "break" LexNewLine
    ;

BreakStatement
    : Break TerminatorSoft { $$ = CYNew CYBreak(NULL); }
    | Break Identifier Terminator { $$ = CYNew CYBreak($2); }
    ;
/* }}} */
/* 13.10 The return Statement {{{ */
Return
    : "!return" LexNewLine
    ;

ReturnStatement
    : Return LexSetRegExp TerminatorSoft { $$ = CYNew CYReturn(NULL); }
    | Return Expression Terminator { $$ = CYNew CYReturn($2); }
    ;
/* }}} */
/* 13.11 The with Statement {{{ */
WithStatement
    : "with" "(" Expression ")" Statement { $$ = CYNew CYWith($3, $5); }
    ;
/* }}} */
/* 13.12 The switch Statement {{{ */
SwitchStatement
    : "switch" "(" Expression ")" CaseBlock { $$ = CYNew CYSwitch($3, $5); }
    ;

CaseBlock
    : BRACE CaseClausesOpt "}" { $$ = $2; }
    ;

CaseClause
    : "case" Expression ":" StatementListOpt { $$ = CYNew CYClause($2, $4); }
    ;

CaseClausesOpt
    : CaseClause CaseClausesOpt { $1->SetNext($2); $$ = $1; }
    | DefaultClause CaseClausesOpt { $1->SetNext($2); $$ = $1; }
    | { $$ = NULL; }
    ;

// XXX: the standard makes certain you can only have one of these
DefaultClause
    : "default" ":" StatementListOpt { $$ = CYNew CYClause(NULL, $3); }
    ;
/* }}} */
/* 13.13 Labelled Statements {{{ */
LabelledStatement
    : LabelIdentifier ":" LabelledItem { $$ = CYNew CYLabel($1, $3); }
    ;

LabelledItem
    : Statement { $$ = $1; }
    | LexSetStatement LexSetRegExp FunctionDeclaration { $$ = $3; }
    ;
/* }}} */
/* 13.14 The throw Statement {{{ */
Throw
    : "throw" LexNewLine
    ;

ThrowStatement
    : Throw LexSetRegExp TerminatorSoft { CYERR(@1, "throw without exception"); }
    | Throw Expression Terminator { $$ = CYNew cy::Syntax::Throw($2); }
    ;
/* }}} */
/* 13.15 The try Statement {{{ */
TryStatement
    : "try" Block Catch { $$ = CYNew cy::Syntax::Try($2, $3, NULL); }
    | "try" Block Finally { $$ = CYNew cy::Syntax::Try($2, NULL, $3); }
    | "try" Block Catch Finally { $$ = CYNew cy::Syntax::Try($2, $3, $4); }
    ;

Catch
    : "catch" "(" CatchParameter ")" Block { $$ = CYNew cy::Syntax::Catch($3, $5); }
    ;

Finally
    : "finally" Block { $$ = CYNew CYFinally($2); }
    ;

CatchParameter
    : BindingIdentifier { $$ = $1; }
    | BindingPattern { CYNOT(@$); }
    ;
/* }}} */
/* 13.16 The debugger Statement {{{ */
DebuggerStatement
    : "debugger" Terminator { $$ = CYNew CYDebugger(); }
    ;
/* }}} */

/* 14.1 Function Definitions {{{ */
FunctionDeclaration
    : ";function" BindingIdentifier "(" FormalParameters ")" BRACE LexPushSuperOff FunctionBody "}" LexPopSuper { $$ = CYNew CYFunctionStatement($2, $4, $8); }
    ;

FunctionExpression
    : "function" BindingIdentifierOpt "(" LexPushInOff FormalParameters ")" LexPopIn BRACE LexPushSuperOff LexPushInOff FunctionBody "}" LexPopIn LexPopSuper { $$ = CYNew CYFunctionExpression($2, $5, $11); }
    ;

StrictFormalParameters
    : FormalParameters { $$ = $1; }
    ;

FormalParameters
    : { $$ = NULL; }
    | FormalParameterList
    ;

FormalParameterList_
    : "," FormalParameterList { $$ = $2; }
    | { $$ = NULL; }
    ;

FormalParameterList
    : FunctionRestParameter { CYNOT(@$); }
    | FormalParameter FormalParameterList_ { $$ = CYNew CYFunctionParameter($1, $2); }
    ;

FunctionRestParameter
    : BindingRestElement
    ;

FormalParameter
    : BindingElement { $$ = $1; }
    ;

FunctionBody
    : LexPushYieldOff FunctionStatementList LexPopYield { $$ = $2; }
    ;

FunctionStatementList
    : LexPushReturnOn StatementListOpt LexPopReturn { $$ = $2; }
    ;
/* }}} */
/* 14.2 Arrow Function Definitions {{{ */
ArrowFunction
    : LexSetRegExp ArrowParameters "=>" LexNoBrace ConciseBody { $$ = CYNew CYFatArrow($2, $5); }
    ;

ArrowParameters
    : BindingIdentifier { $$ = CYNew CYFunctionParameter(CYNew CYDeclaration($1)); }
    | CoverParenthesizedExpressionAndArrowParameterList { if ($1 == NULL) $$ = NULL; else { $$ = $1->expression_->Parameter(); if ($$ == NULL) CYERR(@1, "invalid parameter list"); } }
    ;

ConciseBody
    : AssignmentExpression { $$ = CYNew CYReturn($1); }
    | LexSetRegExp ";{" LexPushInOff FunctionBody "}" LexPopIn { $$ = $4; }
    ;
/* }}} */
/* 14.3 Method Definitions {{{ */
MethodDefinition
    : PropertyName "(" StrictFormalParameters ")" BRACE FunctionBody "}" { $$ = CYNew CYPropertyMethod($1, $3, $6); }
    | GeneratorMethod { $$ = $1; }
    | "get" PropertyName "(" ")" BRACE FunctionBody "}" { $$ = CYNew CYPropertyGetter($2, $6); }
    | "set" PropertyName "(" PropertySetParameterList ")" BRACE FunctionBody "}" { $$ = CYNew CYPropertySetter($2, CYNew CYFunctionParameter($4), $7); }
    ;

PropertySetParameterList
    : FormalParameter { $$ = $1; }
    ;
/* }}} */
/* 14.4 Generator Function Definitions {{{ */
GeneratorMethod
    : "*" PropertyName "(" StrictFormalParameters ")" BRACE GeneratorBody "}" { CYNOT(@$); /* $$ = CYNew CYGeneratorMethod($2, $4, $7); */ }
    ;

GeneratorDeclaration
    : ";function" "*" BindingIdentifier "(" FormalParameters ")" BRACE GeneratorBody "}" { CYNOT(@$); /* $$ = CYNew CYGeneratorStatement($3, $5, $8); */ }
    ;

GeneratorExpression
    : "function" "*" BindingIdentifierOpt "(" FormalParameters ")" BRACE GeneratorBody "}" { CYNOT(@$); /* $$ = CYNew CYGeneratorExpression($3, $5, $8); */ }
    ;

GeneratorBody
    : LexPushYieldOn FunctionStatementList LexPopYield { $$ = $2; }
    ;

Yield
    : "!yield" LexNewLine LexNoStar
    ;

YieldExpression
    : Yield LexSetRegExp NewLineOpt { CYNOT(@$); /* $$ = CYNew CYYieldValue(NULL); */ }
    | Yield AssignmentExpression { CYNOT(@$); /* $$ = CYNew CYYieldValue($2); */ }
    | Yield LexSetRegExp YieldStar AssignmentExpression { CYNOT(@$); /* $$ = CYNew CYYieldGenerator($4); */ }
    ;
/* }}} */
/* 14.5 Class Definitions {{{ */
ClassDeclaration
    : ";class" BindingIdentifier ClassTail { $$ = CYNew CYClassStatement($2, $3); }
    ;

ClassExpression
    : "class" BindingIdentifierOpt ClassTail { $$ = CYNew CYClassExpression($2, $3); }
    ;

ClassTail
    : ClassHeritageOpt { driver.class_.push($1); } BRACE LexPushSuperOn ClassBodyOpt "}" LexPopSuper { driver.class_.pop(); $$ = $1; }
    ;

ClassHeritage
    : "extends" LeftHandSideExpression { $$ = CYNew CYClassTail($2); }
    ;

ClassHeritageOpt
    : ClassHeritage { $$ = $1; }
    | { $$ = CYNew CYClassTail(NULL); }
    ;

ClassBody
    : ClassElementList
    ;

ClassBodyOpt
    : ClassBody
    |
    ;

ClassElementList
    : ClassElementListOpt ClassElement
    ;

ClassElementListOpt
    : ClassElementList
    |
    ;

ClassElement
    : MethodDefinition { if (CYFunctionExpression *constructor = $1->Constructor()) driver.class_.top()->constructor_ = constructor; else driver.class_.top()->instance_->*$1; }
    | "static" MethodDefinition { driver.class_.top()->static_->*$2; }
    | ";"
    ;
/* }}} */

/* 15.1 Scripts {{{ */
Script
    : ScriptBodyOpt { driver.script_ = CYNew CYScript($1); }
    ;

ScriptBody
    : StatementList { $$ = $1; }
    ;

ScriptBodyOpt
    : ScriptBody { $$ = $1; }
    | LexSetStatement LexSetRegExp { $$ = NULL; }
    ;
/* }}} */
/* 15.2 Modules {{{ */
Module
    : ModuleBodyOpt
    ;

ModuleBody
    : ModuleItemList
    ;

ModuleBodyOpt
    : ModuleBody
    |
    ;

ModuleItemList
    : ModuleItemListOpt ModuleItem
    ;

ModuleItemListOpt
    : ModuleItemList
    |
    ;

ModuleItem
    : LexSetStatement LexSetRegExp ImportDeclaration
    | LexSetStatement LexSetRegExp ExportDeclaration
    | StatementListItem
    ;
/* }}} */
/* 15.2.2 Imports {{{ */
ImportDeclaration
    : "import" ImportClause FromClause Terminator
    | "import" ModuleSpecifier Terminator
    ;

ImportClause
    : ImportedDefaultBinding
    | NameSpaceImport
    | NamedImports
    | ImportedDefaultBinding "," NameSpaceImport
    | ImportedDefaultBinding "," NamedImports
    ;

ImportedDefaultBinding
    : ImportedBinding
    ;

NameSpaceImport
    : "*" "as" ImportedBinding
    ;

NamedImports
    : BRACE ImportsListOpt "}"
    ;

FromClause
    : "from" ModuleSpecifier
    ;

ImportsList_
    : "," ImportsListOpt
    |
    ;

ImportsList
    : ImportSpecifier ImportsList_
    ;

ImportsListOpt
    : ImportsList
    |
    ;

ImportSpecifier
    : ImportedBinding
    | IdentifierName "as" ImportedBinding
    ;

ModuleSpecifier
    : StringLiteral
    ;

ImportedBinding
    : BindingIdentifier
    ;
/* }}} */
/* 15.2.3 Exports {{{ */
ExportDeclaration_
    : "*" FromClause Terminator
    | ExportClause FromClause Terminator
    | ExportClause Terminator
    | VariableStatement
    | "default" LexSetStatement LexSetRegExp HoistableDeclaration
    | "default" LexSetStatement LexSetRegExp ClassDeclaration
    | "default" LexSetStatement AssignmentExpression Terminator
    ;

ExportDeclaration
    : "export" LexSetStatement LexSetRegExp ExportDeclaration_
    | "export" Declaration
    ;

ExportClause
    : ";{" ExportsListOpt "}"
    ;

ExportsList_
    : "," ExportsListOpt
    |
    ;

ExportsList
    : ExportSpecifier ExportsList_
    ;

ExportsListOpt
    : ExportsList
    |
    ;

ExportSpecifier
    : IdentifierName
    | IdentifierName "as" IdentifierName
    ;
/* }}} */

@begin C
/* Cycript (C): Type Encoding {{{ */
TypeSignifier
    : IdentifierType { $$ = CYNew CYTypedIdentifier(@1, $1); }
    | "(" LexPushInOff "*" TypeQualifierRight ")" LexPopIn { $$ = $4; }
    ;

SuffixedType
    : SuffixedType "[" NumericLiteral "]" { $$ = $1; $$->modifier_ = CYNew CYTypeArrayOf($3, $$->modifier_); }
    | "(" LexPushInOff "^" TypeQualifierRight ")" LexPopIn "(" LexPushInOff TypedParameterListOpt ")" LexPopIn { $$ = $4; $$->modifier_ = CYNew CYTypeBlockWith($9, $$->modifier_); }
    | TypeSignifier "(" LexPushInOff TypedParameterListOpt ")" LexPopIn { $$ = $1; $$->modifier_ = CYNew CYTypeFunctionWith($4, $$->modifier_); }
    | "(" LexPushInOff TypedParameterListOpt ")" LexPopIn { $$ = CYNew CYTypedIdentifier(@1); $$->modifier_ = CYNew CYTypeFunctionWith($3, $$->modifier_); }
    | TypeSignifier { $$ = $1; }
    | { $$ = CYNew CYTypedIdentifier(@$); }
    ;

PrefixedType
    : "*" TypeQualifierRight { $$ = $2; $$->modifier_ = CYNew CYTypePointerTo($$->modifier_); }
    ;

TypeQualifierLeft
    : { $$ = NULL; }
    | "const" TypeQualifierLeft { $$ = $2; CYSetLast($$) = CYNew CYTypeConstant(); }
    | "volatile" TypeQualifierLeft { $$ = $2; CYSetLast($$) = CYNew CYTypeVolatile(); }
    ;

TypeQualifierRight
    : PrefixedType { $$ = $1; }
    | SuffixedType { $$ = $1; }
    | "const" TypeQualifierRight { $$ = $2; $$->modifier_ = CYNew CYTypeConstant($$->modifier_); }
    | "volatile" TypeQualifierRight { $$ = $2; $$->modifier_ = CYNew CYTypeVolatile($$->modifier_); }
    ;

IntegerType
    : "int" { $$ = CYNew CYTypeVariable("int"); }
    | "unsigned" IntegerTypeOpt { $$ = CYNew CYTypeUnsigned($2); }
    | "signed" IntegerTypeOpt { $$ = CYNew CYTypeSigned($2); }
    | "long" IntegerTypeOpt { $$ = CYNew CYTypeLong($2); }
    | "short" IntegerTypeOpt { $$ = CYNew CYTypeShort($2); }
    ;

IntegerTypeOpt
    : IntegerType { $$ = $1; }
    | { $$ = CYNew CYTypeVariable("int"); }
    ;

PrimitiveType
    : IdentifierType { $$ = CYNew CYTypeVariable($1); }
    | IntegerType { $$ = $1; }
    | "void" { $$ = CYNew CYTypeVoid(); }
    | "char" { $$ = CYNew CYTypeVariable("char"); }
    | "signed" "char" { $$ = CYNew CYTypeSigned(CYNew CYTypeVariable("char")); }
    | "unsigned" "char" { $$ = CYNew CYTypeUnsigned(CYNew CYTypeVariable("char")); }
    ;

TypedIdentifier
    : TypeQualifierLeft PrimitiveType TypeQualifierRight { $$ = $3; $$->specifier_ = $2; CYSetLast($1) = $$->modifier_; $$->modifier_ = $1; }
    ;

PrimaryExpression
    : "@encode" "(" TypedIdentifier ")" { $$ = CYNew CYEncodedType($3); }
    ;
/* }}} */
@end

@begin ObjectiveC
/* Cycript (Objective-C): @class Declaration {{{ */
ClassSuperOpt
    /* XXX: why the hell did I choose MemberExpression? */
    : ":" LexSetRegExp MemberExpression { $$ = $3; }
    | { $$ = NULL; }
    ;

ImplementationFieldListOpt
    : LexSetRegExp TypedIdentifier ";" ImplementationFieldListOpt { $$ = CYNew CYImplementationField($2, $4); }
    | LexSetRegExp { $$ = NULL; }
    ;

ImplementationFields
    : BRACE ImplementationFieldListOpt "}" { $$ = $2; }
    ;

MessageScope
    : "+" { $$ = false; }
    | "-" { $$ = true; }
    ;

TypeOpt
    : "(" LexSetRegExp TypedIdentifier ")" { if ($3->identifier_ != NULL) CYERR($3->location_, "unexpected identifier"); $$ = $3; }
    | { $$ = CYNew CYTypedIdentifier(CYNew CYTypeVariable("id")); }
    ;

MessageParameter
    : Word ":" TypeOpt Identifier { $3->identifier_ = $4; $$ = CYNew CYMessageParameter($1, $3); }
    ;

MessageParameterList
    : MessageParameter MessageParameterListOpt { $1->SetNext($2); $$ = $1; }
    ;

MessageParameterListOpt
    : MessageParameterList { $$ = $1; }
    | { $$ = NULL; }
    ;

MessageParameters
    : MessageParameterList { $$ = $1; }
    | Word { $$ = CYNew CYMessageParameter($1, NULL); }
    ;

ClassMessageDeclaration
    : MessageScope TypeOpt MessageParameters BRACE LexPushSuperOn FunctionBody "}" LexPopSuper { $$ = CYNew CYMessage($1, $2, $3, $6); }
    ;

ClassMessageDeclarationListOpt
    : ClassMessageDeclarationListOpt ClassMessageDeclaration { $2->SetNext($1); $$ = $2; }
    | { $$ = NULL; }
    ;

// XXX: this should be AssignmentExpressionNoRight
ClassProtocols
    : ShiftExpression ClassProtocolsOpt { $$ = CYNew CYProtocol($1, $2); }
    ;

ClassProtocolsOpt
    : "," ClassProtocols { $$ = $2; }
    | { $$ = NULL; }
    ;

ClassProtocolListOpt
    : "<" ClassProtocols ">" { $$ = $2; }
    | { $$ = NULL; }
    ;

ImplementationStatement
    : "@implementation" Identifier ClassSuperOpt ClassProtocolListOpt ImplementationFields ClassMessageDeclarationListOpt "@end" { $$ = CYNew CYImplementation($2, $3, $4, $5, $6); }
    ;

CategoryName
    : "(" WordOpt ")"
    ;

CategoryStatement
    : "@implementation" Identifier CategoryName ClassMessageDeclarationListOpt "@end" { $$ = CYNew CYCategory($2, $4); }
    ;

Statement__
    : ImplementationStatement { $$ = $1; }
    | CategoryStatement { $$ = $1; }
    ;
/* }}} */
/* Cycript (Objective-C): Send Message {{{ */
VariadicCall
    : "," AssignmentExpressionClassic VariadicCall { $$ = CYNew CYArgument(NULL, $2, $3); }
    | { $$ = NULL; }
    ;

SelectorWordOpt
    : WordOpt { driver.contexts_.back().words_.push_back($1); } { $$ = $1; }
    | AutoComplete { driver.mode_ = CYDriver::AutoMessage; YYACCEPT; }
    ;

SelectorCall_
    : SelectorCall { $$ = $1; }
    | VariadicCall { $$ = $1; }
    ;

SelectorCall
    : SelectorWordOpt ":" AssignmentExpressionClassic SelectorCall_ { $$ = CYNew CYArgument($1 ?: CYNew CYWord(""), $3, $4); }
    ;

SelectorList
    : SelectorCall { $$ = $1; }
    | Word { $$ = CYNew CYArgument($1, NULL); }
    ;

MessageExpression
    : "[" LexPushInOff AssignmentExpressionClassic { driver.contexts_.push_back($3); } SelectorList "]" LexPopIn { driver.contexts_.pop_back(); } { $$ = CYNew CYSendDirect($3, $5); }
    | "[" LexPushInOff LexSetRegExp "super" { driver.context_ = NULL; } SelectorList "]" LexPopIn { $$ = CYNew CYSendSuper($6); }
    ;

SelectorExpression_
    : WordOpt ":" SelectorExpressionOpt { $$ = CYNew CYSelectorPart($1, true, $3); }
    ;

SelectorExpression
    : SelectorExpression_ { $$ = $1; }
    | Word { $$ = CYNew CYSelectorPart($1, false, NULL); }
    ;

SelectorExpressionOpt
    : SelectorExpression_ { $$ = $1; }
    | { $$ = NULL; }
    ;

PrimaryExpression
    : MessageExpression { $$ = $1; }
    | "@selector" "(" LexPushInOff SelectorExpression ")" LexPopIn { $$ = CYNew CYSelector($4); }
    ;
/* }}} */
@end

/* Cycript: @import Directive {{{ */
ModulePath
    : ModulePath "." Word { $$ = CYNew CYModule($3, $1); }
    | Word { $$ = CYNew CYModule($1); }
    ;

Declaration__
    : "@import" ModulePath { $$ = CYNew CYImport($2); }
    ;
/* }}} */

@begin ObjectiveC
/* Cycript (Objective-C): Boxed Expressions {{{ */
BoxableExpression
    : NullLiteral { $$ = $1; }
    | BooleanLiteral { $$ = $1; }
    | NumericLiteral { $$ = $1; }
    | StringLiteral { $$ = $1; }
    | ArrayLiteral { $$ = $1; }
    | ObjectLiteral { $$ = $1; }
    | CoverParenthesizedExpressionAndArrowParameterList { $$ = $1; }
    | "YES" { $$ = CYNew CYTrue(); }
    | "NO" { $$ = CYNew CYFalse(); }
    ;

PrimaryExpression
    : "@" BoxableExpression { $$ = CYNew CYBox($2); }
    | "@YES" { $$ = CYNew CYBox(CYNew CYTrue()); }
    | "@NO" { $$ = CYNew CYBox(CYNew CYFalse()); }
    | "@true" { $$ = CYNew CYBox(CYNew CYTrue()); }
    | "@false" { $$ = CYNew CYBox(CYNew CYFalse()); }
    | "@null" { $$ = CYNew CYBox(CYNew CYNull()); }
    ;
/* }}} */
/* Cycript (Objective-C): Block Expressions {{{ */
PrimaryExpression
    : "^" TypedIdentifier { if ($2->identifier_ != NULL) CYERR($2->location_, "unexpected identifier"); } BRACE LexPushInOff FunctionBody "}" LexPopIn { if (CYTypeFunctionWith *function = $2->Function()) $$ = CYNew CYObjCBlock($2, function->parameters_, $6); else CYERR($2->location_, "expected parameters"); }
    ;
/* }}} */
/* Cycript (Objective-C): Instance Literals {{{ */
PrimaryExpression
    : "#" NumericLiteral { $$ = CYNew CYInstanceLiteral($2); }
    ;
/* }}} */
@end

@begin C
/* Cycript (C): Pointer Indirection/Addressing {{{ */
LeftHandSideExpression
    : LexSetRegExp "*" UnaryExpression { $$ = CYNew CYIndirect($3); }
    ;

UnaryExpression_
    : "&" UnaryExpression { $$ = CYNew CYAddressOf($2); }
    ;

MemberAccess
    : "->" "[" Expression "]" { $$ = CYNew CYIndirectMember(NULL, $3); }
    | "->" IdentifierName { $$ = CYNew CYIndirectMember(NULL, CYNew CYString($2)); }
    | "->" AutoComplete { driver.mode_ = CYDriver::AutoIndirect; YYACCEPT; }
    ;
/* }}} */
/* Cycript (C): auto Compatibility {{{ */
Var_
    : "auto"
    ;
/* }}} */
/* Cycript (C): Lambda Expressions {{{ */
TypedParameterList_
    : "," TypedParameterList { $$ = $2; }
    | { $$ = NULL; }
    ;

TypedParameterList
    : TypedIdentifier TypedParameterList_ { $$ = CYNew CYTypedParameter($1, $2); }
    ;

TypedParameterListOpt
    : TypedParameterList { $$ = $1; }
    | { $$ = NULL; }
    ;

PrimaryExpression
    : "[" LexPushInOff LexSetRegExp "&" LexSetRegExp "]" LexPopIn "(" LexPushInOff TypedParameterListOpt ")" LexPopIn "->" TypedIdentifier BRACE LexPushInOff FunctionBody "}" LexPopIn { $$ = CYNew CYLambda($14, $10, $17); }
    ;
/* }}} */
/* Cycript (C): Type Definitions {{{ */
Statement__
    : "typedef" TypedIdentifier { if ($2->identifier_ == NULL) CYERR($2->location_, "expected identifier"); } Terminator { $$ = CYNew CYTypeDefinition($2); }
    ;
/* }}} */
/* Cycript (C): extern "C" {{{ */
Statement__
    : "extern" StringLiteral { if (strcmp($2->Value(), "C") != 0) CYERR(@2, "unknown extern binding"); } TypedIdentifier { if ($4->identifier_ == NULL) CYERR($4->location_, "expected identifier"); } Terminator { $$ = CYNew CYExternal($2, $4); }
    ;
/* }}} */

@end

@begin E4X
/* Lexer State {{{ */
LexPushRegExp
    : { driver.PushCondition(CYDriver::RegExpCondition); }
    ;

LexPushXMLContent
    : { driver.PushCondition(CYDriver::XMLContentCondition); }
    ;

LexPushXMLTag
    : { driver.PushCondition(CYDriver::XMLTagCondition); }
    ;

LexPop
    : { driver.PopCondition(); }
    ;

LexSetXMLContent
    : { driver.SetCondition(CYDriver::XMLContentCondition); }
    ;

LexSetXMLTag
    : { driver.SetCondition(CYDriver::XMLTagCondition); }
    ;
/* }}} */
/* Virtual Tokens {{{ */
XMLWhitespaceOpt
    : XMLWhitespace
    |
    ;
/* }}} */

/* 8.1 Context Keywords {{{ */
Identifier
    : "namespace" { $$ = CYNew CYIdentifier("namespace"); }
    | "xml" { $$ = CYNew CYIdentifier("xml"); }
    ;
/* }}} */
/* 8.3 XML Initializer Input Elements {{{ */
XMLMarkup
    : XMLComment { $$ = $1; }
    | XMLCDATA { $$ = $1; }
    | XMLPI { $$ = $1; }
    ;
/* }}} */

/* 11.1 Primary Expressions {{{ */
PrimaryExpression
    : PropertyIdentifier { $$ = CYNew CYPropertyVariable($1); }
    | XMLInitialiser { $$ = $1; }
    | XMLListInitialiser { $$ = $1; }
    ;

PropertyIdentifier
    : AttributeIdentifier { $$ = $1; }
    | QualifiedIdentifier { $$ = $1; }
    | WildcardIdentifier { $$ = $1; }
    ;
/* }}} */
/* 11.1.1 Attribute Identifiers {{{ */
AttributeIdentifier
    : "@" QualifiedIdentifier_ { $$ = CYNew CYAttribute($2); }
    ;

PropertySelector_
    : PropertySelector { $$ = $1; }
    | "[" LexPushInOff Expression "]" LexPopIn { $$ = CYNew CYSelector($3); }
    ;

PropertySelector
    : Identifier { $$ = CYNew CYSelector($1); }
    | WildcardIdentifier { $$ = $1; }
    ;
/* }}} */
/* 11.1.2 Qualified Identifiers {{{ */
QualifiedIdentifier_
    : PropertySelector_ { $$ = CYNew CYQualified(NULL, $1); }
    | QualifiedIdentifier { $$ = $1; }
    ;

QualifiedIdentifier
    : PropertySelector "::" PropertySelector_ { $$ = CYNew CYQualified($1, $3); }
    ;
/* }}} */
/* 11.1.3 Wildcard Identifiers {{{ */
WildcardIdentifier
    : "*" { $$ = CYNew CYWildcard(); }
    ;
/* }}} */
/* 11.1.4 XML Initializer {{{ */
XMLInitialiser
    : XMLMarkup { $$ = $1; }
    | XMLElement { $$ = $1; }
    ;

XMLElement
    : "<" LexPushInOff XMLTagContent LexPop "/>" LexPopIn
    | "<" LexPushInOff XMLTagContent ">" LexSetXMLContent XMLElementContentOpt "</" LexSetXMLTag XMLTagName XMLWhitespaceOpt LexPop ">" LexPopIn
    ;

XMLTagContent
    : LexPushXMLTag XMLTagName XMLAttributes
    ;

XMLExpression
    : BRACE LexPushRegExp Expression LexPop "}"
    ;

XMLTagName
    : XMLExpression
    | XMLName
    ;

XMLAttributes_
    : XMLAttributes_ XMLAttribute
    |
    ;

XMLAttributes
    : XMLAttributes_ XMLWhitespace XMLExpression XMLWhitespaceOpt
    | XMLAttributes_ XMLWhitespaceOpt
    ;

XMLAttributeValue_
    : XMLExpression
    | XMLAttributeValue
    ;

XMLAttribute
    : XMLWhitespace XMLName XMLWhitespaceOpt "=" XMLWhitespaceOpt XMLAttributeValue_
    ;

XMLElementContent
    : XMLExpression XMLElementContentOpt
    | XMLMarkup XMLElementContentOpt
    | XMLText XMLElementContentOpt
    | XMLElement XMLElementContentOpt
    ;

XMLElementContentOpt
    : XMLElementContent
    |
    ;
/* }}} */
/* 11.1.5 XMLList Initializer {{{ */
XMLListInitialiser
    : "<>" LexPushInOff LexPushXMLContent XMLElementContent LexPop "</>" LexPopIn { $$ = CYNew CYXMLList($4); }
    ;
/* }}} */

/* 11.2 Left-Hand-Side Expressions {{{ */
PropertyIdentifier_
    : Identifier { $$ = $1; }
    | PropertyIdentifier { $$ = $1; }
    ;

MemberAccess
    : "." PropertyIdentifier { $$ = CYNew CYPropertyMember(NULL, $2); }
    | ".." PropertyIdentifier_ { $$ = CYNew CYDescendantMember(NULL, $2); }
    | "." "(" Expression ")" { $$ = CYNew CYFilteringPredicate(NULL, $3); }
    ;
/* }}} */
/* 12.1 The default xml namespace Statement {{{ */
/* XXX: DefaultXMLNamespaceStatement
    : "default" "xml" "namespace" "=" Expression Terminator { $$ = CYNew CYDefaultXMLNamespace($5); }
    ;

Statement__
    : DefaultXMLNamespaceStatement { $$ = $1; }
    ; */
/* }}} */
@end

/* JavaScript FTL: Array Comprehensions {{{ */
Comprehension
    : AssignmentExpression ComprehensionFor ComprehensionTail { $$ = CYNew CYArrayComprehension($1, $2->Modify($3)); }
    ;

ComprehensionFor
    : "for" "each" "(" LexPushInOn LexicalBinding "!in" LexPopIn Expression ")" { $$ = CYNew CYForOfComprehension($5, $8); }
    ;
/* }}} */
/* JavaScript FTL: for each {{{ */
IterationStatement
    : "for" "each" "(" LexPushInOn ForInStatementInitializer "!in" LexPopIn Expression ")" Statement { $$ = CYNew CYForOf($5, $8, $10); }
    ;
/* }}} */

/* JavaScript FTW: Array Comprehensions {{{ */
PrimaryExpression
    : ArrayComprehension
    ;

ArrayComprehension
    : "[" LexPushInOff Comprehension "]" LexPopIn { $$ = $3; }
    ;

Comprehension
    : LexSetRegExp ComprehensionFor ComprehensionTail AssignmentExpression { $$ = CYNew CYArrayComprehension($4, $2->Modify($3)); }
    ;

ComprehensionTail
    : { $$ = NULL; }
    | ComprehensionFor ComprehensionTail { $$ = $1->Modify($2); }
    | ComprehensionIf ComprehensionTail { $$ = $1->Modify($2); }
    ;

ComprehensionFor
    : "for" "(" LexPushInOn ForBinding "!in" LexPopIn Expression ")" { $$ = CYNew CYForInComprehension($4, $7); }
    | "for" "(" LexPushInOn ForBinding "of" LexPopIn Expression ")" { $$ = CYNew CYForOfComprehension($4, $7); }
    ;

ComprehensionIf
    : "if" "(" AssignmentExpression ")" { $$ = CYNew CYIfComprehension($3); }
    ;
/* }}} */
/* JavaScript FTW: Coalesce Operator {{{ */
ConditionalExpression
    : LogicalORExpression "?" LexPushInOff LexSetRegExp ":" LexPopIn AssignmentExpression { $$ = CYNew CYCondition($1, $1, $7); }
    ;
/* }}} */
/* JavaScript FTW: Named Arguments {{{ */
ArgumentList
    : LexSetRegExp Word ":" AssignmentExpression ArgumentList_ { $$ = CYNew CYArgument($2, $4, $5); }
    ;
/* }}} */
/* JavaScript FTW: Ruby Blocks {{{ */
RubyProcParameterList_
    : "," RubyProcParameterList { $$ = $2; }
    | { $$ = NULL; }
    ;

RubyProcParameterList
    : Identifier RubyProcParameterList_ { $$ = CYNew CYFunctionParameter(CYNew CYDeclaration($1), $2); }
    | { $$ = NULL; }
    ;

RubyProcParameters
    : LexSetRegExp "|" RubyProcParameterList "|" { $$ = $3; }
    | LexSetRegExp "||" { $$ = NULL; }
    ;

RubyProcParametersOpt
    : RubyProcParameters { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;

RubyProcExpression
    : "{" RubyProcParametersOpt StatementListOpt "}" { $$ = CYNew CYRubyProc($2, $3); }
    ;

PrimaryExpression
    : BRACE LexPushInOff RubyProcParameters StatementListOpt "}" LexPopIn { $$ = CYNew CYRubyProc($3, $4); }
    ;

PostfixExpression
    : PostfixExpression RubyProcExpression { $$ = CYNew CYRubyBlock($1, $2); }
    ;
/* }}} */

%%

bool CYDriver::Parse(CYMark mark) {
    mark_ = mark;
    CYLocal<CYPool> local(&pool_);
    cy::parser parser(*this);
#ifdef YYDEBUG
    parser.set_debug_level(debug_);
#endif
    return parser.parse() != 0;
}

void CYDriver::Warning(const cy::parser::location_type &location, const char *message) {
    if (!strict_)
        return;

    CYDriver::Error error;
    error.warning_ = true;
    error.location_ = location;
    error.message_ = message;
    errors_.push_back(error);
}

void cy::parser::error(const cy::parser::location_type &location, const std::string &message) {
    CYDriver::Error error;
    error.warning_ = false;
    error.location_ = location;
    error.message_ = message;
    driver.errors_.push_back(error);
}

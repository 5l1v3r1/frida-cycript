/* Cycript - Optimizing JavaScript Compiler/Runtime
 * Copyright (C) 2009-2015  Jay Freeman (saurik)
*/

/* GNU Affero General Public License, Version 3 {{{ */
/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.

 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
**/
/* }}} */

%code top {
#define cyscanner driver.scanner_
#define YYSTACKEXPANDABLE 1
}

%code requires {
#include "Driver.hpp"
#include "Parser.hpp"
#include "Stack.hpp"
#define CYNew new(driver.pool_)

@begin ObjectiveC
#include "ObjectiveC/Syntax.hpp"
@end

@begin E4X
#include "E4X/Syntax.hpp"
@end

#include "Highlight.hpp"
}

%union { bool bool_; }

%union { CYArgument *argument_; }
%union { CYAssignment *assignment_; }
%union { CYBoolean *boolean_; }
%union { CYClause *clause_; }
%union { cy::Syntax::Catch *catch_; }
%union { CYComprehension *comprehension_; }
%union { CYDeclaration *declaration_; }
%union { CYDeclarations *declarations_; }
%union { CYElement *element_; }
%union { CYExpression *expression_; }
%union { CYFalse *false_; }
%union { CYFinally *finally_; }
%union { CYForInitializer *for_; }
%union { CYForInInitializer *forin_; }
%union { CYFunctionParameter *functionParameter_; }
%union { CYIdentifier *identifier_; }
%union { CYInfix *infix_; }
%union { CYLiteral *literal_; }
%union { CYMember *member_; }
%union { CYModule *module_; }
%union { CYNull *null_; }
%union { CYNumber *number_; }
%union { CYParenthetical *parenthetical_; }
%union { CYProperty *property_; }
%union { CYPropertyName *propertyName_; }
%union { CYRubyProc *rubyProc_; }
%union { CYSpan *span_; }
%union { CYStatement *statement_; }
%union { CYString *string_; }
%union { CYThis *this_; }
%union { CYTrue *true_; }
%union { CYWord *word_; }

@begin C
%union { CYTypeModifier *modifier_; }
%union { CYTypeSpecifier *specifier_; }
%union { CYTypedIdentifier *typedIdentifier_; }
%union { CYTypedParameter *typedParameter_; }
@end

@begin ObjectiveC
%union { CYClassName *className_; }
%union { CYClassField *classField_; }
%union { CYMessage *message_; }
%union { CYMessageParameter *messageParameter_; }
%union { CYProtocol *protocol_; }
%union { CYSelectorPart *selector_; }
@end

@begin E4X
%union { CYAttribute *attribute_; }
%union { CYPropertyIdentifier *propertyIdentifier_; }
%union { CYSelector *selector_; }
@end

%code provides {

struct YYSTYPE {
    cy::parser::semantic_type semantic_;
    hi::Value highlight_;
};

int cylex(YYSTYPE *, CYLocation *, void *);

}

%code {

#undef yylex
_finline int yylex(cy::parser::semantic_type *semantic, CYLocation *location, void *scanner) {
    YYSTYPE data;
    int token(cylex(&data, location, scanner));
    *semantic = data.semantic_;
    return token;
}

}

%name-prefix "cy"

%language "C++"

%initial-action {
    @$.begin.filename = @$.end.filename = &driver.filename_;
};

%locations
%defines

%define api.location.type { CYLocation }

//%glr-parser
//%expect 1

%error-verbose

%parse-param { CYDriver &driver }
%lex-param { void *cyscanner }

/* Token Declarations {{{ */
@begin E4X
%token XMLCDATA
%token XMLComment
%token XMLPI

%token XMLAttributeValue
%token XMLName
%token XMLTagCharacters
%token XMLText
%token XMLWhitespace
@end

@begin E4X
%token LeftRight "<>"
%token LeftSlashRight "</>"

%token SlashRight "/>"
%token LeftSlash "</"

%token ColonColon "::"
%token PeriodPeriod ".."
@end

@begin E4X ObjectiveC
%token At "@"
%token Pound "#"
@end

%token Ampersand "&"
%token AmpersandAmpersand "&&"
%token AmpersandEqual "&="
%token Carrot "^"
%token CarrotEqual "^="
%token Equal "="
%token EqualEqual "=="
%token EqualEqualEqual "==="
%token EqualRight "=>"
%token EqualRight_ "\n=>"
%token Exclamation "!"
%token ExclamationEqual "!="
%token ExclamationEqualEqual "!=="
%token Hyphen "-"
%token HyphenEqual "-="
%token HyphenHyphen "--"
%token HyphenHyphen_ "\n--"
%token HyphenRight "->"
%token Left "<"
%token LeftEqual "<="
%token LeftLeft "<<"
%token LeftLeftEqual "<<="
%token Percent "%"
%token PercentEqual "%="
%token Period "."
%token PeriodPeriodPeriod "..."
%token Pipe "|"
%token PipeEqual "|="
%token PipePipe "||"
%token Plus "+"
%token PlusEqual "+="
%token PlusPlus "++"
%token PlusPlus_ "\n++"
%token Right ">"
%token RightEqual ">="
%token RightRight ">>"
%token RightRightEqual ">>="
%token RightRightRight ">>>"
%token RightRightRightEqual ">>>="
%token Slash "/"
%token SlashEqual "/="
%token Star "*"
%token StarEqual "*="
%token Tilde "~"

%token Colon ":"
%token Comma ","
%token Question "?"
%token SemiColon ";"
%token NewLine "\n"

%token Comment

%token OpenParen "("
%token CloseParen ")"

%token OpenBrace "{"
%token OpenBrace_ "\n{"
%token OpenBrace__ ";{"
%token CloseBrace "}"

%token OpenBracket "["
%token CloseBracket "]"

%token At_error_ "@error"

@begin Java
%token At_class_ "@class"
@end

@begin C
%token _typedef_ "typedef"
%token _unsigned_ "unsigned"
%token _signed_ "signed"
%token _extern_ "extern"
@end

@begin C
%token At_encode_ "@encode"
@end

@begin ObjectiveC
%token At_implementation_ "@implementation"
%token At_import_ "@import"
%token At_end_ "@end"
%token At_selector_ "@selector"
%token At_null_ "@null"
%token At_YES_ "@YES"
%token At_NO_ "@NO"
%token At_true_ "@true"
%token At_false_ "@false"
%token _YES_ "YES"
%token _NO_ "NO"
@end

%token _false_ "false"
%token _null_ "null"
%token _true_ "true"

%token _break_ "break"
%token _case_ "case"
%token _catch_ "catch"
%token _class_ "class"
%token _class__ "!class"
%token _const_ "const"
%token _continue_ "continue"
%token _debugger_ "debugger"
%token _default_ "default"
%token _delete_ "delete"
%token _do_ "do"
%token _else_ "else"
%token _enum_ "enum"
%token _export_ "export"
%token _extends_ "extends"
%token _finally_ "finally"
%token _for_ "for"
%token _function_ "function"
%token _function__ ";function"
%token _if_ "if"
%token _import_ "import"
%token _in_ "in"
%token _in__ "!in"
%token _instanceof_ "instanceof"
%token _new_ "new"
%token _return_ "return"
%token _super_ "super"
%token _switch_ "switch"
%token _this_ "this"
%token _throw_ "throw"
%token _try_ "try"
%token _typeof_ "typeof"
%token _var_ "var"
%token _void_ "void"
%token _while_ "while"
%token _with_ "with"

%token _abstract_ "abstract"
%token _await_ "await"
%token _boolean_ "boolean"
%token _byte_ "byte"
%token _char_ "char"
%token _double_ "double"
%token _final_ "final"
%token _float_ "float"
%token _goto_ "goto"
%token _implements_ "implements"
%token _int_ "int"
%token _interface_ "interface"
%token _let_ "let"
%token _long_ "long"
%token _native_ "native"
%token _package_ "package"
%token _private_ "private"
%token _protected_ "protected"
%token _public_ "public"
%token _short_ "short"
%token _static_ "static"
%token _synchronized_ "synchronized"
%token _throws_ "throws"
%token _transient_ "transient"
%token _volatile_ "volatile"
%token _yield_ "yield"

%token _undefined_ "undefined"

@begin ObjectiveC
%token _bool_ "bool"
%token _BOOL_ "BOOL"
%token _id_ "id"
%token _nil_ "nil"
%token _NULL_ "NULL"
%token _SEL_ "SEL"
@end

%token _auto_ "auto"
%token _each_ "each"
%token _of_ "of"

@begin E4X
%token _namespace_ "namespace"
%token _xml_ "xml"
@end

%token AutoComplete

%token <identifier_> Identifier_
%token <number_> NumericLiteral
%token <string_> StringLiteral
%token <literal_> RegularExpressionLiteral

%token <string_> NoSubstitutionTemplate
%token <string_> TemplateHead
%token <string_> TemplateMiddle
%token <string_> TemplateTail

%type <expression_> AdditiveExpression
%type <argument_> ArgumentList_
%type <argument_> ArgumentList
%type <argument_> ArgumentListOpt
%type <argument_> Arguments
%type <expression_> ArrayComprehension
%type <literal_> ArrayLiteral
%type <expression_> ArrowFunction
%type <functionParameter_> ArrowParameters
%type <expression_> AssignmentExpression
%type <expression_> AssignmentExpressionOpt
%type <identifier_> Binding
%type <identifier_> BindingIdentifier
%type <expression_> BitwiseANDExpression
%type <statement_> Block
%type <statement_> BlockStatement
%type <boolean_> BooleanLiteral
%type <declaration_> BindingElement
%type <expression_> BitwiseORExpression
%type <expression_> BitwiseXORExpression
%type <statement_> BreakStatement
%type <statement_> BreakableStatement
%type <expression_> CallExpression_
%type <expression_> CallExpression
%type <clause_> CaseBlock
%type <clause_> CaseClause
%type <clause_> CaseClausesOpt
%type <catch_> Catch
%type <identifier_> CatchParameter
%type <expression_> Comprehension
%type <comprehension_> ComprehensionFor
%type <comprehension_> ComprehensionIf
%type <comprehension_> ComprehensionTail
%type <expression_> ConditionalExpression
%type <statement_> ContinueStatement
%type <statement_> ConciseBody
%type <parenthetical_> CoverParenthesizedExpressionAndArrowParameterList
%type <statement_> DebuggerStatement
%type <statement_> Declaration__
%type <statement_> Declaration_
%type <statement_> Declaration
%type <clause_> DefaultClause
%type <element_> ElementList
%type <element_> ElementListOpt
%type <statement_> ElseStatementOpt
%type <statement_> EmptyStatement
%type <expression_> EqualityExpression
%type <expression_> Expression
%type <expression_> ExpressionOpt
%type <statement_> ExpressionStatement
%type <finally_> Finally
%type <for_> ForStatementInitializer
%type <forin_> ForInStatementInitializer
%type <declaration_> FormalParameter
%type <functionParameter_> FormalParameterList_
%type <functionParameter_> FormalParameterList
%type <functionParameter_> FormalParameterListOpt
%type <statement_> FunctionBody
%type <statement_> FunctionDeclaration
%type <expression_> FunctionExpression
%type <statement_> HoistableDeclaration
%type <identifier_> Identifier
%type <identifier_> IdentifierOpt
%type <identifier_> IdentifierType
%type <word_> IdentifierName
%type <expression_> IdentifierReference
%type <statement_> IfStatement
%type <expression_> Initializer
%type <expression_> InitializerOpt
%type <statement_> IterationStatement
%type <identifier_> LabelIdentifier
%type <statement_> LabelledItem
%type <statement_> LabelledStatement
%type <expression_> LeftHandSideExpression
%type <statement_> LetStatement
%type <statement_> LexicalDeclaration
%type <literal_> Literal
%type <expression_> LogicalANDExpression
%type <expression_> LogicalORExpression
%type <member_> MemberAccess
%type <expression_> MemberExpression_
%type <expression_> MemberExpression
%type <module_> Module
%type <expression_> MultiplicativeExpression
%type <expression_> NewExpression
%type <null_> NullLiteral
%type <literal_> ObjectLiteral
%type <expression_> PostfixExpression
%type <expression_> PrimaryExpression
%type <propertyName_> PropertyName_
%type <propertyName_> PropertyName
%type <property_> PropertyDefinition
%type <property_> PropertyDefinitionList_
%type <property_> PropertyDefinitionList
%type <property_> PropertyDefinitionListOpt
%type <expression_> RelationalExpression
%type <statement_> ReturnStatement
%type <rubyProc_> RubyProcExpression
%type <functionParameter_> RubyProcParameterList_
%type <functionParameter_> RubyProcParameterList
%type <functionParameter_> RubyProcParameters
%type <functionParameter_> RubyProcParametersOpt
%type <statement_> Script
%type <statement_> ScriptBody
%type <statement_> ScriptBodyOpt
%type <expression_> ShiftExpression
%type <declaration_> SingleNameBinding
%type <statement_> Statement__
%type <statement_> Statement_
%type <statement_> Statement
%type <statement_> StatementList
%type <statement_> StatementListOpt
%type <statement_> StatementListItem
%type <statement_> SwitchStatement
%type <expression_> TemplateLiteral
%type <span_> TemplateSpans
%type <statement_> ThrowStatement
%type <statement_> TryStatement
%type <expression_> UnaryExpression_
%type <expression_> UnaryExpression
%type <declaration_> VariableDeclaration
%type <declarations_> VariableDeclarationList_
%type <declarations_> VariableDeclarationList
%type <statement_> VariableStatement
%type <statement_> WithStatement
%type <word_> Word
@begin ObjectiveC
%type <word_> WordOpt
@end

@begin C
%type <specifier_> IntegerType
%type <specifier_> IntegerTypeOpt
%type <typedIdentifier_> PrefixedType
%type <specifier_> PrimitiveType
%type <typedIdentifier_> SuffixedType
%type <typedIdentifier_> TypeSignifier
%type <modifier_> TypeQualifierLeft
%type <typedIdentifier_> TypeQualifierRight
%type <typedIdentifier_> TypedIdentifier
%type <typedParameter_> TypedParameterList_
%type <typedParameter_> TypedParameterList
%type <typedParameter_> TypedParameterListOpt
@end

@begin ObjectiveC
%type <expression_> BoxableExpression
%type <statement_> CategoryStatement
%type <classField_> ClassFieldListOpt
%type <classField_> ClassFields
%type <statement_> ClassStatement
%type <expression_> ClassSuperOpt
%type <message_> ClassMessageDeclaration
%type <message_> ClassMessageDeclarationListOpt
%type <className_> ClassName
%type <protocol_> ClassProtocolListOpt
%type <protocol_> ClassProtocols
%type <protocol_> ClassProtocolsOpt
%type <expression_> MessageExpression
%type <messageParameter_> MessageParameter
%type <messageParameter_> MessageParameters
%type <messageParameter_> MessageParameterList
%type <messageParameter_> MessageParameterListOpt
%type <bool_> MessageScope
%type <argument_> SelectorCall_
%type <argument_> SelectorCall
%type <selector_> SelectorExpression_
%type <selector_> SelectorExpression
%type <selector_> SelectorExpressionOpt
%type <argument_> SelectorList
%type <word_> SelectorWordOpt
%type <typedIdentifier_> TypeOpt
%type <argument_> VariadicCall
@end

@begin E4X
%type <propertyIdentifier_> PropertyIdentifier_
%type <selector_> PropertySelector_
%type <selector_> PropertySelector
%type <identifier_> QualifiedIdentifier_
%type <identifier_> QualifiedIdentifier
%type <identifier_> WildcardIdentifier
%type <identifier_> XMLComment
%type <identifier_> XMLCDATA
%type <identifier_> XMLElement
%type <identifier_> XMLElementContent
%type <identifier_> XMLMarkup
%type <identifier_> XMLPI

%type <attribute_> AttributeIdentifier
/* XXX: %type <statement_> DefaultXMLNamespaceStatement */
%type <expression_> PropertyIdentifier
%type <expression_> XMLListInitialiser
%type <expression_> XMLInitialiser
@end
/* }}} */
/* Token Priorities {{{ */
%nonassoc ""
%left "++" "--"

%nonassoc "if"
%nonassoc "else"
/* }}} */

%start Script

%%

/* Lexer State {{{ */
LexPushInOn
    : { driver.in_.push(true); }
    ;

LexPushInOff
    : { driver.in_.push(false); }
    ;

LexPopIn
    : { driver.in_.pop(); }
    ;

LexSetRegExp
    : { driver.SetCondition(CYDriver::RegExpCondition); }
    ;

LexNoNewLine
    : { if (!yyla.empty() && yyla.type_get() != yyeof_) error(@$, "unexpected lookahead"); driver.no_.NewLine = true; }
    ;

LexNoBrace
    : { if (yyla.empty()) driver.no_.OpenBrace = true; else if (yyla.type == yytranslate_(token::OpenBrace) || yyla.type == yytranslate_(token::OpenBrace_)) yyla.type = yytranslate_(token::OpenBrace__); }
    ;

LexNoClass
    : { if (yyla.empty()) driver.no_.Class = true; else if (yyla.type == yytranslate_(token::_class_)) yyla.type = yytranslate_(token::_class__); }
    ;

LexNoFunction
    : { if (yyla.empty()) driver.no_.Function = true; else if (yyla.type == yytranslate_(token::_function_)) yyla.type = yytranslate_(token::_function__); }
    ;

LexSetStatement
    : LexNoBrace LexNoClass LexNoFunction
    ;
/* }}} */
/* Virtual Tokens {{{ */
BRACE
    : "{"
    | "\n{"
    ;

Var_
    : "var"
    ;
/* }}} */

/* 11.6 Names and Keywords {{{ */
IdentifierName
    : Word { $$ = $1; }
    | "for" { $$ = CYNew CYWord("for"); }
    | "in" { $$ = CYNew CYWord("in"); }
    | "instanceof" { $$ = CYNew CYWord("instanceof"); }
    ;

Word
    : Identifier { $$ = $1; }
    | "auto" { $$ = CYNew CYWord("auto"); }
    | "break" { $$ = CYNew CYWord("break"); }
    | "case" { $$ = CYNew CYWord("case"); }
    | "catch" { $$ = CYNew CYWord("catch"); }
    | "class" { $$ = CYNew CYWord("class"); }
    | "!class" { $$ = CYNew CYWord("class"); }
    | "const" { $$ = CYNew CYWord("const"); }
    | "continue" { $$ = CYNew CYWord("continue"); }
    | "debugger" { $$ = CYNew CYWord("debugger"); }
    | "default" { $$ = CYNew CYWord("default"); }
    | "delete" LexSetRegExp { $$ = CYNew CYWord("delete"); }
    | "do" { $$ = CYNew CYWord("do"); }
    | "else" { $$ = CYNew CYWord("else"); }
    | "enum" { $$ = CYNew CYWord("enum"); }
    | "export" { $$ = CYNew CYWord("export"); }
    | "extends" { $$ = CYNew CYWord("extends"); }
    | "false" { $$ = CYNew CYWord("false"); }
    | "finally" { $$ = CYNew CYWord("finally"); }
    | "function" { $$ = CYNew CYWord("function"); }
    | "if" { $$ = CYNew CYWord("if"); }
    | "import" { $$ = CYNew CYWord("import"); }
    | "!in" { $$ = CYNew CYWord("in"); }
    | "new" LexSetRegExp { $$ = CYNew CYWord("new"); }
    | "null" { $$ = CYNew CYWord("null"); }
    | "return" { $$ = CYNew CYWord("return"); }
    | "super" { $$ = CYNew CYWord("super"); }
    | "switch" { $$ = CYNew CYWord("switch"); }
    | "this" { $$ = CYNew CYWord("this"); }
    | "throw" { $$ = CYNew CYWord("throw"); }
    | "true" { $$ = CYNew CYWord("true"); }
    | "try" { $$ = CYNew CYWord("try"); }
    | "typeof" LexSetRegExp { $$ = CYNew CYWord("typeof"); }
    | "var" { $$ = CYNew CYWord("var"); }
    | "void" LexSetRegExp { $$ = CYNew CYWord("void"); }
    | "while" { $$ = CYNew CYWord("while"); }
    | "with" { $$ = CYNew CYWord("with"); }

    // XXX: should be Identifier
    | "let" { $$ = CYNew CYIdentifier("let"); }
    ;

@begin ObjectiveC
WordOpt
    : Word { $$ = $1; }
    | { $$ = NULL; }
    ;
@end
/* }}} */
/* 11.8.1 Null Literals {{{ */
NullLiteral
    : "null" { $$ = CYNew CYNull(); }
    ;
/* }}} */
/* 11.8.2 Boolean Literals {{{ */
BooleanLiteral
    : "true" { $$ = CYNew CYTrue(); }
    | "false" { $$ = CYNew CYFalse(); }
    ;
/* }}} */

/* 11.9 Automatic Semicolon Insertion {{{ */
StrictSemi
    : { driver.Warning(@$, "warning, automatic semi-colon insertion required"); }
    ;

TerminatorSoft
    : ";"
    | "\n" StrictSemi
    ;

Terminator
    : ";"
    | error { if (yyla.type_get() != yyeof_ && yyla.type != yytranslate_(token::CloseBrace) && !driver.newline_) { error(@1, "required semi-colon"); } else { yyerrok; driver.errors_.pop_back(); } } StrictSemi
    ;

TerminatorOpt
    : ";"
    | error { yyerrok; driver.errors_.pop_back(); } StrictSemi
    ;
/* }}} */

/* 12.1 Identifiers {{{ */
IdentifierReference
    : Identifier { $$ = CYNew CYVariable($1); }
    // XXX: | "yield"
    ;

BindingIdentifier
    : Identifier { $$ = $1; }
    // XXX: | "yield"
    ;

LabelIdentifier
    : Identifier { $$ = $1; }
    // XXX: | yield
    ;

IdentifierType
    : Identifier_ { $$ = $1; }
    | "abstract" { $$ = CYNew CYIdentifier("abstract"); }
    | "await" { $$ = CYNew CYIdentifier("await"); }
    | "boolean" { $$ = CYNew CYIdentifier("boolean"); }
    | "byte" { $$ = CYNew CYIdentifier("byte"); }
    | "double" { $$ = CYNew CYIdentifier("double"); }
    | "each" { $$ = CYNew CYIdentifier("each"); }
    | "final" { $$ = CYNew CYIdentifier("final"); }
    | "float" { $$ = CYNew CYIdentifier("float"); }
    | "goto" { $$ = CYNew CYIdentifier("goto"); }
    | "implements" { $$ = CYNew CYIdentifier("implements"); }
    | "interface" { $$ = CYNew CYIdentifier("interface"); }
    | "native" { $$ = CYNew CYIdentifier("native"); }
    | "of" { $$ = CYNew CYIdentifier("of"); }
    | "package" { $$ = CYNew CYIdentifier("package"); }
    | "private" { $$ = CYNew CYIdentifier("private"); }
    | "protected" { $$ = CYNew CYIdentifier("protected"); }
    | "public" { $$ = CYNew CYIdentifier("public"); }
    | "static" { $$ = CYNew CYIdentifier("static"); }
    | "synchronized" { $$ = CYNew CYIdentifier("synchronized"); }
    | "throws" { $$ = CYNew CYIdentifier("throws"); }
    | "transient" { $$ = CYNew CYIdentifier("transient"); }
    | "yield" { $$ = CYNew CYIdentifier("yield"); }
@begin ObjectiveC
    | "bool" { $$ = CYNew CYIdentifier("bool"); }
    | "BOOL" { $$ = CYNew CYIdentifier("BOOL"); }
    | "id" { $$ = CYNew CYIdentifier("id"); }
    | "SEL" { $$ = CYNew CYIdentifier("SEL"); }
@end
    ;

Identifier
    : IdentifierType
    | "char" { $$ = CYNew CYIdentifier("char"); }
    | "int" { $$ = CYNew CYIdentifier("int"); }
    | "long" { $$ = CYNew CYIdentifier("long"); }
    | "short" { $$ = CYNew CYIdentifier("short"); }
    | "undefined" { $$ = CYNew CYIdentifier("undefined"); }
    | "volatile" { $$ = CYNew CYIdentifier("volatile"); }
@begin C
    | "extern" { $$ = CYNew CYIdentifier("extern"); }
    | "signed" { $$ = CYNew CYIdentifier("signed"); }
    | "typedef" { $$ = CYNew CYIdentifier("typedef"); }
    | "unsigned" { $$ = CYNew CYIdentifier("unsigned"); }
@end
@begin ObjectiveC
    | "nil" { $$ = CYNew CYIdentifier("nil"); }
    | "NO" { $$ = CYNew CYIdentifier("NO"); }
    | "NULL" { $$ = CYNew CYIdentifier("NULL"); }
    | "YES" { $$ = CYNew CYIdentifier("YES"); }
@end
    ;

IdentifierOpt
    : Identifier { $$ = $1; }
    | { $$ = NULL; }
    ;
/* }}} */
/* 12.2 Primary Expression {{{ */
PrimaryExpression
    : "this" { $$ = CYNew CYThis(); }
    | IdentifierReference { $$ = $1; }
    | Literal { $$ = $1; }
    | ArrayLiteral { $$ = $1; }
    | ObjectLiteral { $$ = $1; }
    | RegularExpressionLiteral { $$ = $1; }
    | TemplateLiteral { $$ = $1; }
    | CoverParenthesizedExpressionAndArrowParameterList { if ($1 == NULL) error(@1, "invalid parenthetical"); $$ = $1; }
    | AutoComplete { driver.mode_ = CYDriver::AutoPrimary; YYACCEPT; }
    ;

CoverParenthesizedExpressionAndArrowParameterList
    : "(" LexPushInOff Expression ")" LexPopIn { $$ = CYNew CYParenthetical($3); }
    | "(" LexPushInOff LexSetRegExp ")" LexPopIn { $$ = NULL; }
    ;
/* }}} */
/* 12.2.4 Literals {{{ */
Literal
    : NullLiteral { $$ = $1; }
    | BooleanLiteral { $$ = $1; }
    | NumericLiteral { $$ = $1; }
    | StringLiteral { $$ = $1; }
    ;
/* }}} */
/* 12.2.5 Array Initializer {{{ */
ArrayLiteral
    : "[" LexPushInOff ElementListOpt "]" LexPopIn { $$ = CYNew CYArray($3); }
    ;

ElementList
    : AssignmentExpressionOpt "," ElementListOpt { $$ = CYNew CYElementValue($1, $3); }
    | LexSetRegExp "..." AssignmentExpression { $$ = CYNew CYElementSpread($3); }
    | AssignmentExpression { $$ = CYNew CYElementValue($1, NULL); }
    ;

ElementListOpt
    : ElementList { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;
/* }}} */
/* 12.2.6 Object Initializer {{{ */
ObjectLiteral
    : BRACE LexPushInOff PropertyDefinitionListOpt "}" LexPopIn { $$ = CYNew CYObject($3); }
    ;

PropertyDefinitionList_
    : "," PropertyDefinitionList { $$ = $2; }
    | "," LexSetRegExp { $$ = NULL; }
    | { $$ = NULL; }
    ;

PropertyDefinitionList
    : PropertyDefinition PropertyDefinitionList_ { $1->SetNext($2); $$ = $1; }
    ;

PropertyDefinitionListOpt
    : PropertyDefinitionList { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;

PropertyDefinition
    // XXX: this should be IdentifierName
    : LexSetRegExp Identifier { $$ = CYNew CYProperty($2, CYNew CYVariable($2)); }
    | PropertyName ":" AssignmentExpression { $$ = CYNew CYProperty($1, $3); }
    //| MethodDefinition
    ;

PropertyName_
    : IdentifierName { $$ = $1; }
    | StringLiteral { $$ = $1; }
    | NumericLiteral { $$ = $1; }
    ;

PropertyName
    : LexSetRegExp PropertyName_ { $$ = $2; }
    ;


Initializer
    : "=" AssignmentExpression { $$ = $2; }
    ;

InitializerOpt
    : Initializer { $$ = $1; }
    | { $$ = NULL; }
    ;
/* }}} */
/* 12.2.9 Template Literals {{{ */
TemplateLiteral
    : NoSubstitutionTemplate { $$ = CYNew CYTemplate($1, NULL); }
    | TemplateHead TemplateSpans { $$ = CYNew CYTemplate($1, $2); }
    ;

TemplateSpans
    : Expression TemplateMiddle TemplateSpans { $$ = CYNew CYSpan($1, $2, $3); }
    | Expression TemplateTail { $$ = CYNew CYSpan($1, $2, NULL); }
    ;
/* }}} */

/* 12.3+ Left-Hand-Side Expressions {{{ */
MemberAccess
    : "[" LexPushInOff Expression "]" LexPopIn { $$ = CYNew CYDirectMember(NULL, $3); }
    | "." IdentifierName { $$ = CYNew CYDirectMember(NULL, CYNew CYString($2)); }
    | "." AutoComplete { driver.mode_ = CYDriver::AutoDirect; YYACCEPT; }
    ;

MemberExpression_
    : MemberExpression { $$ = $1; }
    //| "super" { $$ = $1; }
    ;

MemberExpression
    : LexSetRegExp PrimaryExpression { $$ = $2; }
    | LexSetRegExp FunctionExpression { $$ = $2; }
    | MemberExpression_ { driver.context_ = $1; } MemberAccess { $3->SetLeft($1); $$ = $3; }
    | LexSetRegExp "new" MemberExpression Arguments { $$ = CYNew cy::Syntax::New($3, $4); }
    ;

NewExpression
    : MemberExpression { $$ = $1; }
    | LexSetRegExp "new" NewExpression { $$ = CYNew cy::Syntax::New($3, NULL); }
    ;

CallExpression_
    : MemberExpression_
    | CallExpression
    ;

CallExpression
    : CallExpression_ Arguments { $$ = CYNew CYCall($1, $2); }
    | CallExpression { driver.context_ = $1; } MemberAccess { $3->SetLeft($1); $$ = $3; }
    ;

Arguments
    : "(" LexPushInOff ArgumentListOpt ")" LexPopIn { $$ = $3; }
    ;

ArgumentList_
    : "," ArgumentList { $$ = $2; }
    | { $$ = NULL; }
    ;

ArgumentList
    : AssignmentExpression ArgumentList_ { $$ = CYNew CYArgument(NULL, $1, $2); }
    | LexSetRegExp Word ":" AssignmentExpression ArgumentList_ { $$ = CYNew CYArgument($2, $4, $5); }
    ;

ArgumentListOpt
    : ArgumentList { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;

LeftHandSideExpression
    : NewExpression { $$ = $1; }
    | CallExpression { $$ = $1; }
    ;
/* }}} */
/* 12.4 Postfix Expressions {{{ */
PostfixExpression
    : %prec "" LeftHandSideExpression { $$ = $1; }
    | LeftHandSideExpression "++" { $$ = CYNew CYPostIncrement($1); }
    | LeftHandSideExpression "--" { $$ = CYNew CYPostDecrement($1); }
    ;
/* }}} */
/* 12.5 Unary Operators {{{ */
UnaryExpression_
    : "delete" UnaryExpression { $$ = CYNew CYDelete($2); }
    | "void" UnaryExpression { $$ = CYNew CYVoid($2); }
    | "typeof" UnaryExpression { $$ = CYNew CYTypeOf($2); }
    | "++" UnaryExpression { $$ = CYNew CYPreIncrement($2); }
    | "\n++" UnaryExpression { $$ = CYNew CYPreIncrement($2); }
    | "--" UnaryExpression { $$ = CYNew CYPreDecrement($2); }
    | "\n--" UnaryExpression { $$ = CYNew CYPreDecrement($2); }
    | "+" UnaryExpression { $$ = CYNew CYAffirm($2); }
    | "-" UnaryExpression { $$ = CYNew CYNegate($2); }
    | "~" UnaryExpression { $$ = CYNew CYBitwiseNot($2); }
    | "!" UnaryExpression { $$ = CYNew CYLogicalNot($2); }
    ;

UnaryExpression
    : PostfixExpression { $$ = $1; }
    | LexSetRegExp UnaryExpression_ { $$ = $2; }
    ;
/* }}} */
/* 12.6 Multiplicative Operators {{{ */
MultiplicativeExpression
    : UnaryExpression { $$ = $1; }
    | MultiplicativeExpression "*" UnaryExpression { $$ = CYNew CYMultiply($1, $3); }
    | MultiplicativeExpression "/" UnaryExpression { $$ = CYNew CYDivide($1, $3); }
    | MultiplicativeExpression "%" UnaryExpression { $$ = CYNew CYModulus($1, $3); }
    ;
/* }}} */
/* 12.7 Additive Operators {{{ */
AdditiveExpression
    : MultiplicativeExpression { $$ = $1; }
    | AdditiveExpression "+" MultiplicativeExpression { $$ = CYNew CYAdd($1, $3); }
    | AdditiveExpression "-" MultiplicativeExpression { $$ = CYNew CYSubtract($1, $3); }
    ;
/* }}} */
/* 12.8 Bitwise Shift Operators {{{ */
ShiftExpression
    : AdditiveExpression { $$ = $1; }
    | ShiftExpression "<<" AdditiveExpression { $$ = CYNew CYShiftLeft($1, $3); }
    | ShiftExpression ">>" AdditiveExpression { $$ = CYNew CYShiftRightSigned($1, $3); }
    | ShiftExpression ">>>" AdditiveExpression { $$ = CYNew CYShiftRightUnsigned($1, $3); }
    ;
/* }}} */
/* 12.9 Relational Operators {{{ */
RelationalExpression
    : ShiftExpression { $$ = $1; }
    | RelationalExpression "<" ShiftExpression { $$ = CYNew CYLess($1, $3); }
    | RelationalExpression ">" ShiftExpression { $$ = CYNew CYGreater($1, $3); }
    | RelationalExpression "<=" ShiftExpression { $$ = CYNew CYLessOrEqual($1, $3); }
    | RelationalExpression ">=" ShiftExpression { $$ = CYNew CYGreaterOrEqual($1, $3); }
    | RelationalExpression "instanceof" ShiftExpression { $$ = CYNew CYInstanceOf($1, $3); }
    | RelationalExpression "in" ShiftExpression { $$ = CYNew CYIn($1, $3); }
    ;
/* }}} */
/* 12.10 Equality Operators {{{ */
EqualityExpression
    : RelationalExpression { $$ = $1; }
    | EqualityExpression "==" RelationalExpression { $$ = CYNew CYEqual($1, $3); }
    | EqualityExpression "!=" RelationalExpression { $$ = CYNew CYNotEqual($1, $3); }
    | EqualityExpression "===" RelationalExpression { $$ = CYNew CYIdentical($1, $3); }
    | EqualityExpression "!==" RelationalExpression { $$ = CYNew CYNotIdentical($1, $3); }
    ;
/* }}} */
/* 12.11 Binary Bitwise Operators {{{ */
BitwiseANDExpression
    : EqualityExpression { $$ = $1; }
    | BitwiseANDExpression "&" EqualityExpression { $$ = CYNew CYBitwiseAnd($1, $3); }
    ;

BitwiseXORExpression
    : BitwiseANDExpression { $$ = $1; }
    | BitwiseXORExpression "^" BitwiseANDExpression { $$ = CYNew CYBitwiseXOr($1, $3); }
    ;

BitwiseORExpression
    : BitwiseXORExpression { $$ = $1; }
    | BitwiseORExpression "|" BitwiseXORExpression { $$ = CYNew CYBitwiseOr($1, $3); }
    ;
/* }}} */
/* 12.12 Binary Logical Operators {{{ */
LogicalANDExpression
    : BitwiseORExpression { $$ = $1; }
    | LogicalANDExpression "&&" BitwiseORExpression { $$ = CYNew CYLogicalAnd($1, $3); }
    ;

LogicalORExpression
    : LogicalANDExpression { $$ = $1; }
    | LogicalORExpression "||" LogicalANDExpression { $$ = CYNew CYLogicalOr($1, $3); }
    ;
/* }}} */
/* 12.13 Conditional Operator ( ? : ) {{{ */
ConditionalExpression
    : LogicalORExpression { $$ = $1; }
    | LogicalORExpression "?" LexPushInOff AssignmentExpression ":" LexPopIn AssignmentExpression { $$ = CYNew CYCondition($1, $4, $7); }
    ;
/* }}} */
/* 12.14 Assignment Operators {{{ */
AssignmentExpression
    : ConditionalExpression { $$ = $1; }
    // XXX: | YieldExpression { $$ = $1; }
    | ArrowFunction { $$ = $1; }
    | LeftHandSideExpression "=" AssignmentExpression { $$ = CYNew CYAssign($1, $3); }
    | LeftHandSideExpression "*=" AssignmentExpression { $$ = CYNew CYMultiplyAssign($1, $3); }
    | LeftHandSideExpression "/=" AssignmentExpression { $$ = CYNew CYDivideAssign($1, $3); }
    | LeftHandSideExpression "%=" AssignmentExpression { $$ = CYNew CYModulusAssign($1, $3); }
    | LeftHandSideExpression "+=" AssignmentExpression { $$ = CYNew CYAddAssign($1, $3); }
    | LeftHandSideExpression "-=" AssignmentExpression { $$ = CYNew CYSubtractAssign($1, $3); }
    | LeftHandSideExpression "<<=" AssignmentExpression { $$ = CYNew CYShiftLeftAssign($1, $3); }
    | LeftHandSideExpression ">>=" AssignmentExpression { $$ = CYNew CYShiftRightSignedAssign($1, $3); }
    | LeftHandSideExpression ">>>=" AssignmentExpression { $$ = CYNew CYShiftRightUnsignedAssign($1, $3); }
    | LeftHandSideExpression "&=" AssignmentExpression { $$ = CYNew CYBitwiseAndAssign($1, $3); }
    | LeftHandSideExpression "^=" AssignmentExpression { $$ = CYNew CYBitwiseXOrAssign($1, $3); }
    | LeftHandSideExpression "|=" AssignmentExpression { $$ = CYNew CYBitwiseOrAssign($1, $3); }
    ;

AssignmentExpressionOpt
    : AssignmentExpression { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;
/* }}} */
/* 12.15 Comma Operator ( , ) {{{ */
Expression
    : AssignmentExpression { $$ = $1; }
    /* XXX: I have this backwards... */
    | AssignmentExpression "," Expression { $$ = CYNew CYCompound($1, $3); }
    ;

ExpressionOpt
    : Expression { $$ = $1; }
    | LexSetRegExp { $$ = NULL; }
    ;
/* }}} */

/* 13 Statements and Declarations {{{ */
Statement__
    : BlockStatement { $$ = $1; }
    | VariableStatement { $$ = $1; }
    | EmptyStatement { $$ = $1; }
    | IfStatement { $$ = $1; }
    | BreakableStatement { $$ = $1; }
    | ContinueStatement { $$ = $1; }
    | BreakStatement { $$ = $1; }
    | ReturnStatement { $$ = $1; }
    | WithStatement { $$ = $1; }
    | LabelledStatement { $$ = $1; }
    | ThrowStatement { $$ = $1; }
    | TryStatement { $$ = $1; }
    | DebuggerStatement { $$ = $1; }
    ;

Statement_
    : LexSetRegExp Statement__ { $$ = $2; }
    | ExpressionStatement { $$ = $1; }
    ;

Statement
    : LexSetStatement Statement_ { $$ = $2; }
    ;

Declaration__
    : HoistableDeclaration { $$ = $1; }
    // XXX: | ClassDeclaration { $$ = $1; }
    | LexicalDeclaration { $$ = $1; }
    ;

Declaration_
    : LexSetRegExp Declaration__ { $$ = $2; }
    ;

Declaration
    : LexSetStatement Declaration_ { $$ = $2; }
    ;

HoistableDeclaration
    : FunctionDeclaration
    // XXX: | GeneratorDeclaration
    ;

BreakableStatement
    : IterationStatement { $$ = $1; }
    | SwitchStatement { $$ = $1; }
    ;
/* }}} */
/* 13.2 Block {{{ */
BlockStatement
    : ";{" StatementListOpt "}" { $$ = CYNew CYBlock($2); }
    ;

Block
    : BRACE StatementListOpt "}" { $$ = $2; }
    ;

StatementList
    : StatementListItem StatementListOpt { $1->SetNext($2); $$ = $1; }
    ;

StatementListOpt
    : StatementList { $$ = $1; }
    | LexSetStatement LexSetRegExp { $$ = NULL; }
    ;

StatementListItem
    : Statement { $$ = $1; }
    | Declaration { $$ = $1; }
    ;
/* }}} */
/* 13.3+ Let and Const Declarations {{{ */
LexicalDeclaration
    : LetOrConst VariableDeclarationList Terminator { $$ = CYNew CYVar($2); }
    ;

LetOrConst
    : "let"
    | "const"
    ;

Binding
    : BindingIdentifier
    ;

// XXX: lots of binding stuff
/* }}} */
/* 13.3.2+ Variable Statement {{{ */
VariableStatement
    : Var_ VariableDeclarationList Terminator { $$ = CYNew CYVar($2); }
    ;

VariableDeclarationList_
    : "," VariableDeclarationList { $$ = $2; }
    | { $$ = NULL; }
    ;

VariableDeclarationList
    : VariableDeclaration VariableDeclarationList_ { $$ = CYNew CYDeclarations($1, $2); }
    ;

VariableDeclaration
    : BindingIdentifier InitializerOpt { $$ = CYNew CYDeclaration($1, $2); }
    // XXX: | BindingPattern Initializer { $$ = CYNew CYDeclaration($1, $2); }
    ;
/* }}} */
/* 13.3.3+ Destructuring Binding Patterns {{{ */
// XXX: *

BindingElement
    : SingleNameBinding { $$ = $1; }
    ;

SingleNameBinding
    : BindingIdentifier InitializerOpt { $$ = CYNew CYDeclaration($1, $2); }
    ;
/* }}} */
/* 13.4 Empty Statement {{{ */
EmptyStatement
    : ";" { $$ = CYNew CYEmpty(); }
    ;
/* }}} */
/* 13.5 Expression Statement {{{ */
ExpressionStatement
    : Expression Terminator { $$ = CYNew CYExpress($1); }
    ;
/* }}} */
/* 13.6 The if Statement {{{ */
ElseStatementOpt
    : "else" Statement { $$ = $2; }
    | %prec "if" { $$ = NULL; }
    ;

IfStatement
    : "if" "(" Expression ")" Statement ElseStatementOpt { $$ = CYNew CYIf($3, $5, $6); }
    ;
/* }}} */
/* 13.7+ Iteration Statements {{{ */
IterationStatement
    : "do" Statement "while" "(" Expression ")" TerminatorOpt { $$ = CYNew CYDoWhile($5, $2); }
    | "while" "(" Expression ")" Statement { $$ = CYNew CYWhile($3, $5); }
    | "for" "(" LexPushInOn ForStatementInitializer ";" LexPopIn ExpressionOpt ";" ExpressionOpt ")" Statement { $$ = CYNew CYFor($4, $7, $9, $11); }
    | "for" "(" LexPushInOn ForInStatementInitializer "!in" LexPopIn Expression ")" Statement { $$ = CYNew CYForIn($4, $7, $9); }
    | "for" "(" LexPushInOn ForInStatementInitializer "of" LexPopIn Expression ")" Statement { $$ = CYNew CYForOf($4, $7, $9); }
    ;

ForStatementInitializer
    : ExpressionOpt { $$ = $1; }
    | LexSetRegExp Var_ VariableDeclarationList { $$ = CYNew CYForDeclarations($3); }
    ;

ForInStatementInitializer
    : LeftHandSideExpression { $$ = $1; }
    | LexSetRegExp Var_ VariableDeclaration { $$ = $3; }
    ;
/* }}} */
/* 13.8 The continue Statement {{{ */
Continue
    : "continue" LexNoNewLine
    ;

ContinueStatement
    : Continue TerminatorSoft { $$ = CYNew CYContinue(NULL); }
    | Continue Identifier Terminator { $$ = CYNew CYContinue($2); }
    ;
/* }}} */
/* 13.9 The break Statement {{{ */
Break
    : "break" LexNoNewLine
    ;

BreakStatement
    : Break TerminatorSoft { $$ = CYNew CYBreak(NULL); }
    | Break Identifier Terminator { $$ = CYNew CYBreak($2); }
    ;
/* }}} */
/* 13.10 The return Statement {{{ */
Return
    : "return" LexNoNewLine
    ;

ReturnStatement
    : Return LexSetRegExp TerminatorSoft { $$ = CYNew CYReturn(NULL); }
    | Return Expression Terminator { $$ = CYNew CYReturn($2); }
    ;
/* }}} */
/* 13.11 The with Statement {{{ */
WithStatement
    : "with" "(" Expression ")" Statement { $$ = CYNew CYWith($3, $5); }
    ;
/* }}} */
/* 13.12 The switch Statement {{{ */
SwitchStatement
    : "switch" "(" Expression ")" CaseBlock { $$ = CYNew CYSwitch($3, $5); }
    ;

CaseBlock
    : BRACE CaseClausesOpt "}" { $$ = $2; }
    ;

CaseClause
    : "case" Expression ":" StatementListOpt { $$ = CYNew CYClause($2, $4); }
    ;

CaseClausesOpt
    : CaseClause CaseClausesOpt { $1->SetNext($2); $$ = $1; }
    | DefaultClause CaseClausesOpt { $1->SetNext($2); $$ = $1; }
    | { $$ = NULL; }
    ;

// XXX: the standard makes certain you can only have one of these
DefaultClause
    : "default" ":" StatementListOpt { $$ = CYNew CYClause(NULL, $3); }
    ;
/* }}} */
/* 13.13 Labelled Statements {{{ */
LabelledStatement
    : LabelIdentifier ":" LabelledItem { $$ = CYNew CYLabel($1, $3); }
    ;

LabelledItem
    : Statement { $$ = $1; }
    | LexSetStatement LexSetRegExp FunctionDeclaration { $$ = $3; }
    ;
/* }}} */
/* 13.14 The throw Statement {{{ */
Throw
    : "throw" LexNoNewLine
    ;

ThrowStatement
    : Throw LexSetRegExp TerminatorSoft { error(@1, "throw without exception"); }
    | Throw Expression Terminator { $$ = CYNew cy::Syntax::Throw($2); }
    ;
/* }}} */
/* 13.15 The try Statement {{{ */
TryStatement
    : "try" Block Catch { $$ = CYNew cy::Syntax::Try($2, $3, NULL); }
    | "try" Block Finally { $$ = CYNew cy::Syntax::Try($2, NULL, $3); }
    | "try" Block Catch Finally { $$ = CYNew cy::Syntax::Try($2, $3, $4); }
    ;

Catch
    : "catch" "(" CatchParameter ")" Block { $$ = CYNew cy::Syntax::Catch($3, $5); }
    ;

Finally
    : "finally" Block { $$ = CYNew CYFinally($2); }
    ;

CatchParameter
    : BindingIdentifier { $$ = $1; }
    // XXX: BindingPattern
    ;
/* }}} */
/* 13.16 The debugger Statement {{{ */
DebuggerStatement
    : "debugger" Terminator { $$ = CYNew CYDebugger(); }
    ;
/* }}} */

/* 14.1+ Function Definitions {{{ */
FunctionDeclaration
    : ";function" Identifier "(" FormalParameterListOpt ")" BRACE FunctionBody "}" { $$ = CYNew CYFunctionStatement($2, $4, $7); }
    ;

FunctionExpression
    : "function" IdentifierOpt "(" LexPushInOff FormalParameterListOpt ")" LexPopIn BRACE LexPushInOff FunctionBody "}" LexPopIn { $$ = CYNew CYFunctionExpression($2, $5, $10); }
    ;

FormalParameterList_
    : "," FormalParameterList { $$ = $2; }
    | { $$ = NULL; }
    ;

FormalParameterList
    // XXX: : FunctionRestParameter { $$ = $1; }
    : FormalParameter FormalParameterList_ { $$ = CYNew CYFunctionParameter($1, $2); }
    ;

FormalParameterListOpt
    : FormalParameterList
    | { $$ = NULL; }
    ;

/* XXX: FunctionRestParameter
    : "..." BindingIdentifier { $$ = CYNew CYFunctionRestParameter($2); }
    ;*/

FormalParameter
    : BindingElement { $$ = $1; }
    ;

FunctionBody
    : StatementListOpt { $$ = $1; }
    ;
/* }}} */
/* 14.2 Arrow Function Definitions {{{ */
ArrowFunction
    : LexSetRegExp ArrowParameters "=>" LexNoBrace ConciseBody { $$ = CYNew CYFatArrow($2, $5); }
    ;

ArrowParameters
    : BindingIdentifier { $$ = CYNew CYFunctionParameter(CYNew CYDeclaration($1)); }
    | CoverParenthesizedExpressionAndArrowParameterList { $$ = $1->expression_->Parameter(); if ($$ == NULL) error(@1, "invalid parameter list"); }
    ;

ConciseBody
    : AssignmentExpression { $$ = CYNew CYReturn($1); }
    | LexSetRegExp ";{" LexPushInOff FunctionBody "}" LexPopIn { $$ = $4; }
    ;
/* }}} */
/* 14.3+ Method Definitions {{{ */
/* }}} */
/* 14.4+ Generator Function Definitions {{{ */
/* }}} */
/* 14.5+ Class Definitions {{{ */
/* }}} */

/* 15.1 Scripts {{{ */
Script
    : ScriptBodyOpt { driver.script_ = CYNew CYScript($1); }
    ;

ScriptBody
    : StatementList { $$ = $1; }
    ;

ScriptBodyOpt
    : ScriptBody { $$ = $1; }
    | LexSetStatement LexSetRegExp { $$ = NULL; }
    ;
/* }}} */
/* 15.2+ Modules {{{ */
/* }}} */
/* 15.2.2+ Imports {{{ */
/* }}} */
/* 15.2.3+ Exports {{{ */
/* }}} */

@begin C
/* Cycript (C): Type Encoding {{{ */
TypeSignifier
    : IdentifierType { $$ = CYNew CYTypedIdentifier(@1, $1); }
    | "(" LexPushInOff "*" TypeQualifierRight ")" LexPopIn { $$ = $4; }
    ;

SuffixedType
    : SuffixedType "[" NumericLiteral "]" { $$ = $1; $$->modifier_ = CYNew CYTypeArrayOf($3, $$->modifier_); }
    | "(" LexPushInOff "^" TypeQualifierRight ")" LexPopIn "(" LexPushInOff TypedParameterListOpt ")" LexPopIn { $$ = $4; $$->modifier_ = CYNew CYTypeBlockWith($9, $$->modifier_); }
    | TypeSignifier "(" LexPushInOff TypedParameterListOpt ")" LexPopIn { $$ = $1; $$->modifier_ = CYNew CYTypeFunctionWith($4, $$->modifier_); }
    | "(" LexPushInOff TypedParameterListOpt ")" LexPopIn { $$ = CYNew CYTypedIdentifier(@1); $$->modifier_ = CYNew CYTypeFunctionWith($3, $$->modifier_); }
    | TypeSignifier { $$ = $1; }
    | { $$ = CYNew CYTypedIdentifier(@$); }
    ;

PrefixedType
    : "*" TypeQualifierRight { $$ = $2; $$->modifier_ = CYNew CYTypePointerTo($$->modifier_); }
    ;

TypeQualifierLeft
    : { $$ = NULL; }
    | "const" TypeQualifierLeft { $$ = $2; CYSetLast($$) = CYNew CYTypeConstant(); }
    | "volatile" TypeQualifierLeft { $$ = $2; CYSetLast($$) = CYNew CYTypeVolatile(); }
    ;

TypeQualifierRight
    : PrefixedType { $$ = $1; }
    | SuffixedType { $$ = $1; }
    | "const" TypeQualifierRight { $$ = $2; $$->modifier_ = CYNew CYTypeConstant($$->modifier_); }
    | "volatile" TypeQualifierRight { $$ = $2; $$->modifier_ = CYNew CYTypeVolatile($$->modifier_); }
    ;

IntegerType
    : "int" { $$ = CYNew CYTypeVariable("int"); }
    | "unsigned" IntegerTypeOpt { $$ = CYNew CYTypeUnsigned($2); }
    | "signed" IntegerTypeOpt { $$ = CYNew CYTypeSigned($2); }
    | "long" IntegerTypeOpt { $$ = CYNew CYTypeLong($2); }
    | "short" IntegerTypeOpt { $$ = CYNew CYTypeShort($2); }
    ;

IntegerTypeOpt
    : IntegerType { $$ = $1; }
    | { $$ = CYNew CYTypeVariable("int"); }
    ;

PrimitiveType
    : IdentifierType { $$ = CYNew CYTypeVariable($1); }
    | IntegerType { $$ = $1; }
    | "void" { $$ = CYNew CYTypeVoid(); }
    | "char" { $$ = CYNew CYTypeVariable("char"); }
    | "signed" "char" { $$ = CYNew CYTypeSigned(CYNew CYTypeVariable("char")); }
    | "unsigned" "char" { $$ = CYNew CYTypeUnsigned(CYNew CYTypeVariable("char")); }
    ;

TypedIdentifier
    : TypeQualifierLeft PrimitiveType TypeQualifierRight { $$ = $3; $$->specifier_ = $2; CYSetLast($1) = $$->modifier_; $$->modifier_ = $1; }
    ;

PrimaryExpression
    : "@encode" "(" TypedIdentifier ")" { $$ = CYNew CYEncodedType($3); }
    ;
/* }}} */
@end

@begin ObjectiveC
/* Cycript (Objective-C): @class Declaration {{{ */
ClassSuperOpt
    /* XXX: why the hell did I choose MemberExpression? */
    : ":" LexSetRegExp MemberExpression { $$ = $3; }
    | { $$ = NULL; }
    ;

ClassFieldListOpt
    : TypedIdentifier ";" ClassFieldListOpt { $$ = CYNew CYClassField($1, $3); }
    | LexSetRegExp { $$ = NULL; }
    ;

ClassFields
    : BRACE ClassFieldListOpt "}" { $$ = $2; }
    ;

MessageScope
    : "+" { $$ = false; }
    | "-" { $$ = true; }
    ;

TypeOpt
    : "(" LexSetRegExp TypedIdentifier ")" { if ($3->identifier_ != NULL) error($3->location_, "unexpected identifier"); $$ = $3; }
    | { $$ = CYNew CYTypedIdentifier(CYNew CYTypeVariable("id")); }
    ;

MessageParameter
    : Word ":" TypeOpt Identifier { $3->identifier_ = $4; $$ = CYNew CYMessageParameter($1, $3); }
    ;

MessageParameterList
    : MessageParameter MessageParameterListOpt { $1->SetNext($2); $$ = $1; }
    ;

MessageParameterListOpt
    : MessageParameterList { $$ = $1; }
    | { $$ = NULL; }
    ;

MessageParameters
    : MessageParameterList { $$ = $1; }
    | Word { $$ = CYNew CYMessageParameter($1, NULL); }
    ;

ClassMessageDeclaration
    : MessageScope TypeOpt MessageParameters BRACE FunctionBody "}" { $$ = CYNew CYMessage($1, $2, $3, $5); }
    ;

ClassMessageDeclarationListOpt
    : ClassMessageDeclarationListOpt ClassMessageDeclaration { $2->SetNext($1); $$ = $2; }
    | { $$ = NULL; }
    ;

ClassName
    : Identifier { $$ = $1; }
    | "(" AssignmentExpression ")" { $$ = $2; }
    ;

// XXX: this should be AssignmentExpressionNoRight
ClassProtocols
    : ShiftExpression ClassProtocolsOpt { $$ = CYNew CYProtocol($1, $2); }
    ;

ClassProtocolsOpt
    : "," ClassProtocols { $$ = $2; }
    | { $$ = NULL; }
    ;

ClassProtocolListOpt
    : "<" ClassProtocols ">" { $$ = $2; }
    | { $$ = NULL; }
    ;

ClassStatement
    : "@implementation" ClassName ClassSuperOpt ClassProtocolListOpt ClassFields ClassMessageDeclarationListOpt "@end" { $$ = CYNew CYClassStatement($2, $3, $4, $5, $6); }
    ;

CategoryName
    : "(" WordOpt ")"
    ;

CategoryStatement
    : "@implementation" ClassName CategoryName ClassMessageDeclarationListOpt "@end" { $$ = CYNew CYCategory($2, $4); }
    ;

Statement__
    : ClassStatement { $$ = $1; }
    | CategoryStatement { $$ = $1; }
    ;
/* }}} */
/* Cycript (Objective-C): Send Message {{{ */
VariadicCall
    : "," AssignmentExpression VariadicCall { $$ = CYNew CYArgument(NULL, $2, $3); }
    | { $$ = NULL; }
    ;

SelectorWordOpt
    : WordOpt { driver.contexts_.back().words_.push_back($1); } { $$ = $1; }
    | AutoComplete { driver.mode_ = CYDriver::AutoMessage; YYACCEPT; }
    ;

SelectorCall_
    : SelectorCall { $$ = $1; }
    | VariadicCall { $$ = $1; }
    ;

SelectorCall
    : SelectorWordOpt ":" AssignmentExpression SelectorCall_ { $$ = CYNew CYArgument($1 ?: CYNew CYWord(""), $3, $4); }
    ;

SelectorList
    : SelectorCall { $$ = $1; }
    | Word { $$ = CYNew CYArgument($1, NULL); }
    ;

MessageExpression
    : "[" LexPushInOff AssignmentExpression { driver.contexts_.push_back($3); } SelectorList "]" LexPopIn { driver.contexts_.pop_back(); } { $$ = CYNew CYSendDirect($3, $5); }
    | "[" LexPushInOff LexSetRegExp "super" { driver.context_ = NULL; } SelectorList "]" LexPopIn { $$ = CYNew CYSendSuper($6); }
    ;

SelectorExpression_
    : WordOpt ":" SelectorExpressionOpt { $$ = CYNew CYSelectorPart($1, true, $3); }
    ;

SelectorExpression
    : SelectorExpression_ { $$ = $1; }
    | Word { $$ = CYNew CYSelectorPart($1, false, NULL); }
    ;

SelectorExpressionOpt
    : SelectorExpression_ { $$ = $1; }
    | { $$ = NULL; }
    ;

PrimaryExpression
    : MessageExpression { $$ = $1; }
    | "@selector" "(" LexPushInOff SelectorExpression ")" LexPopIn { $$ = CYNew CYSelector($4); }
    ;
/* }}} */
@end

/* Cycript: @import Directive {{{ */
Module
    : Module "." Word { $$ = CYNew CYModule($3, $1); }
    | Word { $$ = CYNew CYModule($1); }
    ;

Declaration__
    : "@import" Module { $$ = CYNew CYImport($2); }
    ;
/* }}} */

@begin ObjectiveC
/* Cycript (Objective-C): Boxed Expressions {{{ */
BoxableExpression
    : NullLiteral { $$ = $1; }
    | BooleanLiteral { $$ = $1; }
    | NumericLiteral { $$ = $1; }
    | StringLiteral { $$ = $1; }
    | ArrayLiteral { $$ = $1; }
    | ObjectLiteral { $$ = $1; }
    | CoverParenthesizedExpressionAndArrowParameterList { $$ = $1; }
    | "YES" { $$ = CYNew CYTrue(); }
    | "NO" { $$ = CYNew CYFalse(); }
    ;

PrimaryExpression
    : "@" BoxableExpression { $$ = CYNew CYBox($2); }
    | "@YES" { $$ = CYNew CYBox(CYNew CYTrue()); }
    | "@NO" { $$ = CYNew CYBox(CYNew CYFalse()); }
    | "@true" { $$ = CYNew CYBox(CYNew CYTrue()); }
    | "@false" { $$ = CYNew CYBox(CYNew CYFalse()); }
    | "@null" { $$ = CYNew CYBox(CYNew CYNull()); }
    ;
/* }}} */
/* Cycript (Objective-C): Block Expressions {{{ */
PrimaryExpression
    : "^" TypedIdentifier { if ($2->identifier_ != NULL) error($2->location_, "unexpected identifier"); } BRACE LexPushInOff FunctionBody "}" LexPopIn { if (CYTypeFunctionWith *function = $2->Function()) $$ = CYNew CYObjCBlock($2, function->parameters_, $6); else error($2->location_, "expected parameters"); }
    ;
/* }}} */
/* Cycript (Objective-C): Instance Literals {{{ */
PrimaryExpression
    : "#" NumericLiteral { $$ = CYNew CYInstanceLiteral($2); }
    ;
/* }}} */
@end

@begin C
/* Cycript (C): Pointer Indirection/Addressing {{{ */
LeftHandSideExpression
    : LexSetRegExp "*" UnaryExpression { $$ = CYNew CYIndirect($3); }
    ;

UnaryExpression_
    : "&" UnaryExpression { $$ = CYNew CYAddressOf($2); }
    ;

MemberAccess
    : "->" "[" Expression "]" { $$ = CYNew CYIndirectMember(NULL, $3); }
    | "->" IdentifierName { $$ = CYNew CYIndirectMember(NULL, CYNew CYString($2)); }
    | "->" AutoComplete { driver.mode_ = CYDriver::AutoIndirect; YYACCEPT; }
    ;
/* }}} */
/* Cycript (C): auto Compatibility {{{ */
Var_
    : "auto"
    ;
/* }}} */
/* Cycript (C): Lambda Expressions {{{ */
TypedParameterList_
    : "," TypedParameterList { $$ = $2; }
    | { $$ = NULL; }
    ;

TypedParameterList
    : TypedIdentifier TypedParameterList_ { $$ = CYNew CYTypedParameter($1, $2); }
    ;

TypedParameterListOpt
    : TypedParameterList { $$ = $1; }
    | { $$ = NULL; }
    ;

PrimaryExpression
    : "[" LexPushInOff LexSetRegExp "&" LexSetRegExp "]" LexPopIn "(" LexPushInOff TypedParameterListOpt ")" LexPopIn "->" TypedIdentifier BRACE LexPushInOff FunctionBody "}" LexPopIn { $$ = CYNew CYLambda($14, $10, $17); }
    ;
/* }}} */
/* Cycript (C): Type Definitions {{{ */
Statement__
    : "typedef" TypedIdentifier { if ($2->identifier_ == NULL) error($2->location_, "expected identifier"); } Terminator { $$ = CYNew CYTypeDefinition($2); }
    ;
/* }}} */
/* Cycript (C): extern "C" {{{ */
Statement__
    : "extern" StringLiteral { if (strcmp($2->Value(), "C") != 0) error(@2, "unknown extern binding"); } TypedIdentifier { if ($4->identifier_ == NULL) error($4->location_, "expected identifier"); } Terminator { $$ = CYNew CYExternal($2, $4); }
    ;
/* }}} */

@end

@begin E4X
/* Lexer State {{{ */
LexPushRegExp
    : { driver.PushCondition(CYDriver::RegExpCondition); }
    ;

LexPushXMLContent
    : { driver.PushCondition(CYDriver::XMLContentCondition); }
    ;

LexPushXMLTag
    : { driver.PushCondition(CYDriver::XMLTagCondition); }
    ;

LexPop
    : { driver.PopCondition(); }
    ;

LexSetXMLContent
    : { driver.SetCondition(CYDriver::XMLContentCondition); }
    ;

LexSetXMLTag
    : { driver.SetCondition(CYDriver::XMLTagCondition); }
    ;
/* }}} */
/* Virtual Tokens {{{ */
XMLWhitespaceOpt
    : XMLWhitespace
    |
    ;
/* }}} */

/* 8.1 Context Keywords {{{ */
Identifier
    : "namespace" { $$ = CYNew CYIdentifier("namespace"); }
    | "xml" { $$ = CYNew CYIdentifier("xml"); }
    ;
/* }}} */
/* 8.3 XML Initializer Input Elements {{{ */
XMLMarkup
    : XMLComment { $$ = $1; }
    | XMLCDATA { $$ = $1; }
    | XMLPI { $$ = $1; }
    ;
/* }}} */

/* 11.1 Primary Expressions {{{ */
PrimaryExpression
    : PropertyIdentifier { $$ = CYNew CYPropertyVariable($1); }
    | XMLInitialiser { $$ = $1; }
    | XMLListInitialiser { $$ = $1; }
    ;

PropertyIdentifier
    : AttributeIdentifier { $$ = $1; }
    | QualifiedIdentifier { $$ = $1; }
    | WildcardIdentifier { $$ = $1; }
    ;
/* }}} */
/* 11.1.1 Attribute Identifiers {{{ */
AttributeIdentifier
    : "@" QualifiedIdentifier_ { $$ = CYNew CYAttribute($2); }
    ;

PropertySelector_
    : PropertySelector { $$ = $1; }
    | "[" LexPushInOff Expression "]" LexPopIn { $$ = CYNew CYSelector($3); }
    ;

PropertySelector
    : Identifier { $$ = CYNew CYSelector($1); }
    | WildcardIdentifier { $$ = $1; }
    ;
/* }}} */
/* 11.1.2 Qualified Identifiers {{{ */
QualifiedIdentifier_
    : PropertySelector_ { $$ = CYNew CYQualified(NULL, $1); }
    | QualifiedIdentifier { $$ = $1; }
    ;

QualifiedIdentifier
    : PropertySelector "::" PropertySelector_ { $$ = CYNew CYQualified($1, $3); }
    ;
/* }}} */
/* 11.1.3 Wildcard Identifiers {{{ */
WildcardIdentifier
    : "*" { $$ = CYNew CYWildcard(); }
    ;
/* }}} */
/* 11.1.4 XML Initializer {{{ */
XMLInitialiser
    : XMLMarkup { $$ = $1; }
    | XMLElement { $$ = $1; }
    ;

XMLElement
    : "<" LexPushInOff XMLTagContent LexPop "/>" LexPopIn
    | "<" LexPushInOff XMLTagContent ">" LexSetXMLContent XMLElementContentOpt "</" LexSetXMLTag XMLTagName XMLWhitespaceOpt LexPop ">" LexPopIn
    ;

XMLTagContent
    : LexPushXMLTag XMLTagName XMLAttributes
    ;

XMLExpression
    : BRACE LexPushRegExp Expression LexPop "}"
    ;

XMLTagName
    : XMLExpression
    | XMLName
    ;

XMLAttributes_
    : XMLAttributes_ XMLAttribute
    |
    ;

XMLAttributes
    : XMLAttributes_ XMLWhitespace XMLExpression XMLWhitespaceOpt
    | XMLAttributes_ XMLWhitespaceOpt
    ;

XMLAttributeValue_
    : XMLExpression
    | XMLAttributeValue
    ;

XMLAttribute
    : XMLWhitespace XMLName XMLWhitespaceOpt "=" XMLWhitespaceOpt XMLAttributeValue_
    ;

XMLElementContent
    : XMLExpression XMLElementContentOpt
    | XMLMarkup XMLElementContentOpt
    | XMLText XMLElementContentOpt
    | XMLElement XMLElementContentOpt
    ;

XMLElementContentOpt
    : XMLElementContent
    |
    ;
/* }}} */
/* 11.1.5 XMLList Initializer {{{ */
XMLListInitialiser
    : "<>" LexPushInOff LexPushXMLContent XMLElementContent LexPop "</>" LexPopIn { $$ = CYNew CYXMLList($4); }
    ;
/* }}} */

/* 11.2 Left-Hand-Side Expressions {{{ */
PropertyIdentifier_
    : Identifier { $$ = $1; }
    | PropertyIdentifier { $$ = $1; }
    ;

MemberAccess
    : "." PropertyIdentifier { $$ = CYNew CYPropertyMember(NULL, $2); }
    | ".." PropertyIdentifier_ { $$ = CYNew CYDescendantMember(NULL, $2); }
    | "." "(" Expression ")" { $$ = CYNew CYFilteringPredicate(NULL, $3); }
    ;
/* }}} */
/* 12.1 The default xml namespace Statement {{{ */
/* XXX: DefaultXMLNamespaceStatement
    : "default" "xml" "namespace" "=" Expression Terminator { $$ = CYNew CYDefaultXMLNamespace($5); }
    ;

Statement__
    : DefaultXMLNamespaceStatement { $$ = $1; }
    ; */
/* }}} */
@end

/* JavaScript FTL: Array Comprehensions {{{ */
Comprehension
    : AssignmentExpression ComprehensionFor ComprehensionTail { $$ = CYNew CYArrayComprehension($1, $2->Modify($3)); }
    ;

ComprehensionFor
    : "for" "(" Binding "in" Expression ")" { $$ = CYNew CYForInComprehension($3, $5); }
    | "for" "each" "(" Binding "in" Expression ")" { $$ = CYNew CYForOfComprehension($4, $6); }
    ;
/* }}} */
/* JavaScript FTL: for each {{{ */
IterationStatement
    : "for" "each" "(" LexPushInOn ForInStatementInitializer "!in" LexPopIn Expression ")" Statement { $$ = CYNew CYForOf($5, $8, $10); }
    ;
/* }}} */
/* JavaScript FTL: let Statements {{{ */
LetStatement
    : "let" "(" VariableDeclarationList ")" Statement { $$ = CYNew CYLetStatement($3, $5); }
    ;

Statement__
    : LetStatement
    ;
/* }}} */

/* JavaScript FTW: Array Comprehensions {{{ */
PrimaryExpression
    : ArrayComprehension
    ;

ArrayComprehension
    : "[" LexPushInOff Comprehension "]" LexPopIn { $$ = $3; }
    ;

Comprehension
    : LexSetRegExp ComprehensionFor ComprehensionTail AssignmentExpression { $$ = CYNew CYArrayComprehension($4, $2->Modify($3)); }
    ;

ComprehensionTail
    : { $$ = NULL; }
    | ComprehensionFor ComprehensionTail { $$ = $1->Modify($2); }
    | ComprehensionIf ComprehensionTail { $$ = $1->Modify($2); }
    ;

ComprehensionFor
    : "for" "(" Binding "of" Expression ")" { $$ = CYNew CYForOfComprehension($3, $5); }
    ;

ComprehensionIf
    : "if" "(" AssignmentExpression ")" { $$ = CYNew CYIfComprehension($3); }
    ;
/* }}} */
/* JavaScript FTW: Coalesce Operator {{{ */
ConditionalExpression
    : LogicalORExpression "?" LexPushInOff LexSetRegExp ":" LexPopIn AssignmentExpression { $$ = CYNew CYCondition($1, $1, $7); }
    ;
/* }}} */
/* JavaScript FTW: Ruby Blocks {{{ */
RubyProcParameterList_
    : "," RubyProcParameterList { $$ = $2; }
    | { $$ = NULL; }
    ;

RubyProcParameterList
    : Identifier RubyProcParameterList_ { $$ = CYNew CYFunctionParameter(CYNew CYDeclaration($1), $2); }
    | { $$ = NULL; }
    ;

RubyProcParameters
    : "|" RubyProcParameterList "|" { $$ = $2; }
    | "||" { $$ = NULL; }
    ;

RubyProcParametersOpt
    : RubyProcParameters
    | { $$ = NULL; }
    ;

RubyProcExpression
    : "{" RubyProcParametersOpt StatementListOpt "}" { $$ = CYNew CYRubyProc($2, $3); }
    ;

PrimaryExpression
    : "{" LexPushInOff RubyProcParameters StatementListOpt "}" LexPopIn { $$ = CYNew CYRubyProc($3, $4); }
    ;

CallExpression
    : CallExpression_ RubyProcExpression { $$ = CYNew CYRubyBlock($1, $2); }
    ;
/* }}} */

%%
